{"version":3,"sources":["pages/InteractiveCode.module.css","ga/viz2d.tsx","ga/ga_zpp.ts","util.tsx","pages/SRTimeDilation.tsx","pages/SRLengthContraction.tsx","pages/SRElectromagnetism.tsx","App.tsx","ga/ga_pp.ts","ga/ga_ppp.ts","pages/InteractiveCode.tsx","reportWebVitals.ts","index.tsx","pages/TutorialIndex.tsx","pages/Motivation.tsx","pages/GATutorial.tsx","pages/CodeGATutorial.ts","pages/PGATutorial.tsx","pages/CodePGATutorial.ts","pages/PGAGeometryTutorial.tsx","pages/CoffeeShop.tsx","pages/GADesign1.tsx","pages/GADesign2.tsx","pages/GADesignInterpolatingPoints.tsx","pages/SRIntro.tsx","pages/SRGAReview.tsx","pages/SRSpacetimeAlgebra.tsx","pages/SRMeasuring.tsx","pages/SRSpacetimeRotors.tsx"],"names":["module","exports","pointCoordinates","a","magInv","e12","e02","e01","PointElementPGA2D","props","point","radius","fill","label","trailCount","trailStroke","x","y","useState","trail","setTrail","trailPolyPoints","useMemo","flat","join","updateTrail","useCallback","length","newTrail","slice","push","useEffect","pga","stroke","strokeWidth","points","cx","cy","r","dominantBaseline","fontWeight","textAnchor","fontSize","LineElementPGA2D","line","width","lineCoords","Math","abs","e2","e1","e0","x1","y1","x2","y2","SVGGrid","rows","cols","i","getThickness","index","map","toFixed","SceneView","scene","style","viewBox","preserveAspectRatio","height","transform","lines","l","key","p","infos","info","color","text","add","b","scalar","undefined","e012","sub","dual","geometricProduct","resultScalar","scalar_0","scalar_1","scalar_2","scalar_3","resultE0","e0_0","e0_1","e0_2","e0_3","e0_4","e0_5","e0_6","e0_7","resultE1","e1_0","e1_1","e1_2","e1_3","resultE2","e2_0","e2_1","e2_2","e2_3","resultE01","e01_0","e01_1","e01_2","e01_3","e01_4","e01_5","e01_6","e01_7","resultE02","e02_0","e02_1","e02_2","e02_3","e02_4","e02_5","e02_6","e02_7","resultE12","e12_0","e12_1","e12_2","e12_3","resultE012","e012_0","e012_1","e012_2","e012_3","e012_4","e012_5","e012_6","e012_7","innerProduct","exteriorProduct","multiply","div","reversion","repr","digits","result","regressiveProduct","sandwichProduct","commutatorProduct","exponential","s","rootS","sign","sqrt","cos","sin","cosh","sinh","useMathJax","eval","ImageWithSub","src","padding","textAlign","alt","SRTimeDilation","textDecorationColor","textDecorationThickness","href","to","SRLengthContraction","SRElectromagnetism","breadcrumbPathToName","pathToBreadcrumbs","path","pathNames","pathUrls","cleanedPath","substr","pathSplit","split","pathElement","splice","name","url","NotFound","TutorialSite","location","useLocation","breadcrumbs","pathname","c","reduce","className","id","exact","App","wnd","window","ga","ga3d","viz","renderScene","renderTarget","ReactDOM","render","scalar_4","scalar_5","scalar_6","scalar_7","e1_4","e1_5","e1_6","e1_7","e2_4","e2_5","e2_6","e2_7","e12_4","e12_5","e12_6","e12_7","formatObject","obj","toString","JSON","stringify","InteractiveCode","sourceCode","editorStyle","hideOutput","withVisualizer","visualizerStyle","outputStyle","code","setCode","runResult","setRunResult","run","oldLog","console","log","newRunResults","message","optionalParams","codeToRun","visualizerRef","current","e","uniqueId","random","useRef","styles","position","border","background","right","top","zIndex","onClick","display","flexDirection","alignContent","flexWrap","mode","theme","value","onChange","showPrintMargin","ref","readOnly","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","getApp","StrictMode","rootElement","document","getElementById","hasChildNodes","hydrate","TutorialIndex","Motivation","GATutorial","PGATutorial","PGAGeometryTutorial","CoffeeShop","title","frameBorder","GADesign1","GADesign2","GADesignInterpolatingPoints","SRIntro","SRGAReview","SRSpacetimeAlgebra","loop","autoPlay","playsInline","muted","margin","SRMeasuring","SRSpacetimeRotors"],"mappings":"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","file":"static/js/main.934b11d3.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"interactive-code\":\"InteractiveCode_interactive-code__1W_Ca\",\"interactive-code-editor-with-viz\":\"InteractiveCode_interactive-code-editor-with-viz__3vc2f\",\"interactive-code-editor-without-viz\":\"InteractiveCode_interactive-code-editor-without-viz__23QwE\",\"interactive-code-viz\":\"InteractiveCode_interactive-code-viz__1atqK\",\"interactive-code-output\":\"InteractiveCode_interactive-code-output__2M2TB\"};","import React, { useCallback, useState, useEffect, useMemo } from \"react\"\r\nimport * as pga from \"./ga_zpp\"\r\n\r\n\r\nexport const pointCoordinates = (a: pga.BiVector): [number, number] => {\r\n    const magInv = 1 / a.e12\r\n    return [-a.e02 * magInv, a.e01 * magInv]\r\n}\r\n\r\nexport type PointElementPGA2DProps = {\r\n    point: pga.BiVector\r\n    radius?: number\r\n    fill?: string\r\n    label?: string\r\n    trailCount?: number\r\n    trailStroke?: string\r\n}\r\n\r\nconst getPolyLinePoints = (points: [number, number][]): string =>\r\n    points.flat().join(\" \")\r\n\r\n\r\nexport function PointElementPGA2D(props: PointElementPGA2DProps) {\r\n    const { point, radius, fill, label, trailCount, trailStroke } = props\r\n\r\n    const x = -point.e02 / point.e12\r\n    const y = point.e01 / point.e12\r\n\r\n    const [trail, setTrail] = useState<[number, number][]>([])\r\n\r\n    const trailPolyPoints = useMemo(() => getPolyLinePoints(trail), [trail])\r\n\r\n    const updateTrail = useCallback(() => {\r\n        if (trailCount) {\r\n            if (trail.length === 0 || (trail[trail.length - 1][0] !== x || trail[trail.length - 1][1] !== y)) {\r\n                let newTrail = [...trail]\r\n                if (newTrail.length > trailCount) {\r\n                    newTrail = newTrail.slice(1)\r\n                }\r\n                newTrail.push([x, y])\r\n                setTrail(newTrail)\r\n            }\r\n        } else {\r\n            setTrail([])\r\n        }\r\n    }, [x, y, trail, trailCount])\r\n\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    useEffect(updateTrail, [x, y])\r\n\r\n    return (\r\n        <g>\r\n            <title>{pga.repr(point)}</title>\r\n            {trail.length > 0 &&\r\n                <polyline fill=\"none\" stroke={trailStroke || \"#F37121\"}\r\n                    strokeWidth={0.5 * (radius || 1)}\r\n                    points={trailPolyPoints} />\r\n            }\r\n\r\n            <circle cx={x} cy={-y} r={radius || 1} fill={fill || \"#F37121\"} stroke=\"white\" />\r\n\r\n            {label &&\r\n                <text x={x} y={-y} dominantBaseline=\"middle\"\r\n                    fontWeight=\"800\"\r\n                    textAnchor=\"middle\" fontSize={radius || 1}>\r\n                    {label}\r\n                </text>\r\n            }\r\n        </g>\r\n    )\r\n}\r\n\r\nexport type LineElementPGA2DProps = {\r\n    line: pga.Vector\r\n    width?: number\r\n    stroke?: string\r\n    label?: string\r\n}\r\n\r\nexport function LineElementPGA2D(props: LineElementPGA2DProps) {\r\n    let { line, width, stroke, label } = props\r\n\r\n    const lineCoords = useMemo(() => {\r\n        if (Math.abs(line.e2) > Math.abs(line.e1)) {\r\n            const startX = -100\r\n            const endX = 100\r\n            const startY = -(line.e1 * startX + line.e0) / line.e2\r\n            const endY = -(line.e1 * endX + line.e0) / line.e2\r\n            return [startX, startY, endX, endY]\r\n        } else {\r\n            const startY = -100\r\n            const endY = 100\r\n            const startX = -(line.e2 * startY + line.e0) / line.e1\r\n            const endX = -(line.e2 * endY + line.e0) / line.e1\r\n            return [startX, startY, endX, endY]\r\n        }\r\n    }, [line])\r\n\r\n    return (\r\n        <g>\r\n            <title>{pga.repr(line)}</title>\r\n            <line x1={lineCoords[0]} y1={-lineCoords[1]} x2={lineCoords[2]} y2={-lineCoords[3]}\r\n                strokeWidth={width || 1} stroke={stroke || \"#F37121\"} />\r\n\r\n            {label &&\r\n                <text x={(lineCoords[0] + lineCoords[2]) / 2} y={-0.5 * (lineCoords[1] + lineCoords[3])}\r\n                    dominantBaseline=\"middle\" fontWeight=\"800\"\r\n                    textAnchor=\"middle\" fontSize={1}>\r\n                    {label}\r\n                </text>\r\n            }\r\n        </g>\r\n    )\r\n}\r\n\r\nexport type InfoElementProps = {\r\n    text: string\r\n    fontSize?: number\r\n    color?: string\r\n}\r\n\r\nexport type Scene = {\r\n    points?: PointElementPGA2DProps[]\r\n    lines?: LineElementPGA2DProps[]\r\n    infos?: InfoElementProps[]\r\n}\r\n\r\nexport type SceneViewProps = {\r\n    scene: Scene\r\n    style?: React.CSSProperties\r\n}\r\n\r\nfunction SVGGrid() {\r\n    const rows: number[] = []\r\n    const cols: number[] = []\r\n    for (let i = -10; i <= 10; i++) {\r\n        rows.push(i)\r\n        cols.push(i)\r\n    }\r\n\r\n    const getThickness = useCallback((index: number) => {\r\n        if (index === 0) {\r\n            return 1\r\n        } else if (index % 5 === 0) {\r\n            return 0.5\r\n        }\r\n\r\n        return 0.25\r\n    }, [])\r\n\r\n    return (\r\n        <g>\r\n            <g>\r\n                {cols.map(x =>\r\n                    <g key={x}>\r\n                        <line x1={x * 10} x2={x * 10} y1={100} y2={-100} stroke=\"#CCCCCC\" strokeWidth={getThickness(x)} />\r\n                        {x % 2 === 0 && x !== 0 && (\r\n                            <text x={10 * x} y={-2} fill=\"white\" fontSize={5} textAnchor=\"middle\">\r\n                                {`${(10 * x).toFixed(0)}`}\r\n                            </text>\r\n                        )}\r\n                    </g>\r\n                )}\r\n            </g>\r\n\r\n            <g>\r\n                {rows.map(y =>\r\n                    <g key={y}>\r\n                        <line x1={-100} x2={100} y1={-y * 10} y2={-y * 10} stroke=\"#CCCCCC\" strokeWidth={getThickness(y)} />\r\n                        {(y % 2 === 0) && (\r\n                            <text x={5} y={-(10 * y + 2)} fill=\"white\" fontSize={5} textAnchor=\"middle\">\r\n                                {`${(10 * y).toFixed(0)}`}\r\n                            </text>\r\n                        )}\r\n                    </g>\r\n                )}\r\n            </g>\r\n        </g>\r\n    )\r\n}\r\n\r\nexport function SceneView(props: SceneViewProps) {\r\n    const { scene, style } = props\r\n\r\n    return (\r\n        <svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMinYMin slice\" style={style}>\r\n            <rect fill=\"#111D6E\" width=\"100%\" height=\"100%\" />\r\n\r\n            <g transform=\"translate(50, 50) scale(0.5)\">\r\n                <SVGGrid />\r\n\r\n                {scene.lines && scene.lines.map((l, i) =>\r\n                    <LineElementPGA2D {...l} key={i} />\r\n                )}\r\n\r\n                {scene.points && scene.points.map((p, i) =>\r\n                    <PointElementPGA2D {...p} key={i} />\r\n                )}\r\n            </g>\r\n\r\n            {scene.infos && scene.infos.map((info, i) => {\r\n                return (\r\n                    <text key={i} fontWeight=\"100\" x={1} y={5 + 5 * i} fontSize={info.fontSize || 1} fill={info.color || \"white\"}>\r\n                        {info.text}\r\n                    </text>\r\n                )\r\n            })}\r\n        </svg>\r\n    )\r\n}","export type BladeScalar = { scalar: number }\r\nexport type BladeE0 = { e0: number }\r\nexport type BladeE1 = { e1: number }\r\nexport type BladeE2 = { e2: number }\r\nexport type BladeE01 = { e01: number }\r\nexport type BladeE02 = { e02: number }\r\nexport type BladeE12 = { e12: number }\r\nexport type BladeE012 = { e012: number }\r\n\r\nexport type Scalar = BladeScalar\r\nexport type Vector = BladeE0 & BladeE1 & BladeE2\r\nexport type BiVector = BladeE01 & BladeE02 & BladeE12\r\nexport type TriVector = BladeE012\r\nexport type PseudoTriVector = BladeScalar\r\nexport type PseudoBiVector = BladeE0 & BladeE1 & BladeE2\r\nexport type PseudoVector = BladeE01 & BladeE02 & BladeE12\r\nexport type PseudoScalar = BladeE012\r\nexport type Even = BladeScalar & BladeE01 & BladeE02 & BladeE12\r\nexport type Odd = BladeE0 & BladeE1 & BladeE2 & BladeE012\r\nexport type MultiVector = BladeScalar & BladeE0 & BladeE1 & BladeE2 & BladeE01 & BladeE02 & BladeE12 & BladeE012\r\n\r\nexport type OptionalMultiVector = {\r\n    scalar?: number\r\n    e0?: number\r\n    e1?: number\r\n    e2?: number\r\n    e01?: number\r\n    e02?: number\r\n    e12?: number\r\n    e012?: number\r\n}\r\n\r\nexport type AddResultType<A, B> = (\r\n    (A extends BladeScalar ? BladeScalar : {}) &\r\n    (B extends BladeScalar ? BladeScalar : {}) &\r\n    (A extends BladeE0 ? BladeE0 : {}) &\r\n    (B extends BladeE0 ? BladeE0 : {}) &\r\n    (A extends BladeE1 ? BladeE1 : {}) &\r\n    (B extends BladeE1 ? BladeE1 : {}) &\r\n    (A extends BladeE2 ? BladeE2 : {}) &\r\n    (B extends BladeE2 ? BladeE2 : {}) &\r\n    (A extends BladeE01 ? BladeE01 : {}) &\r\n    (B extends BladeE01 ? BladeE01 : {}) &\r\n    (A extends BladeE02 ? BladeE02 : {}) &\r\n    (B extends BladeE02 ? BladeE02 : {}) &\r\n    (A extends BladeE12 ? BladeE12 : {}) &\r\n    (B extends BladeE12 ? BladeE12 : {}) &\r\n    (A extends BladeE012 ? BladeE012 : {}) &\r\n    (B extends BladeE012 ? BladeE012 : {})\r\n)\r\n\r\nexport const add = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) + (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) + (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) + (b.e1 || 0) : undefined,\r\n        e2: (a.e2 !== undefined || b.e2 !== undefined) ? (a.e2 || 0) + (b.e2 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) + (b.e01 || 0) : undefined,\r\n        e02: (a.e02 !== undefined || b.e02 !== undefined) ? (a.e02 || 0) + (b.e02 || 0) : undefined,\r\n        e12: (a.e12 !== undefined || b.e12 !== undefined) ? (a.e12 || 0) + (b.e12 || 0) : undefined,\r\n        e012: (a.e012 !== undefined || b.e012 !== undefined) ? (a.e012 || 0) + (b.e012 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport const sub = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) - (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) - (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) - (b.e1 || 0) : undefined,\r\n        e2: (a.e2 !== undefined || b.e2 !== undefined) ? (a.e2 || 0) - (b.e2 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) - (b.e01 || 0) : undefined,\r\n        e02: (a.e02 !== undefined || b.e02 !== undefined) ? (a.e02 || 0) - (b.e02 || 0) : undefined,\r\n        e12: (a.e12 !== undefined || b.e12 !== undefined) ? (a.e12 || 0) - (b.e12 || 0) : undefined,\r\n        e012: (a.e012 !== undefined || b.e012 !== undefined) ? (a.e012 || 0) - (b.e012 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport type DualResultType<A> = (\r\n    (A extends BladeScalar ? BladeE012 : {}) &\r\n    (A extends BladeE0 ? BladeE12 : {}) &\r\n    (A extends BladeE1 ? BladeE02 : {}) &\r\n    (A extends BladeE2 ? BladeE01 : {}) &\r\n    (A extends BladeE01 ? BladeE2 : {}) &\r\n    (A extends BladeE02 ? BladeE1 : {}) &\r\n    (A extends BladeE12 ? BladeE0 : {}) &\r\n    (A extends BladeE012 ? BladeScalar : {})\r\n)\r\n\r\nexport const dual = <A extends OptionalMultiVector>(a: A): DualResultType<A> => {\r\n    const result: any = {\r\n        scalar: a.e012 !== undefined ? 1.0 * a.e012 : undefined,\r\n        e0: a.e12 !== undefined ? 1.0 * a.e12 : undefined,\r\n        e1: a.e02 !== undefined ? -1.0 * a.e02 : undefined,\r\n        e2: a.e01 !== undefined ? 1.0 * a.e01 : undefined,\r\n        e01: a.e2 !== undefined ? 1.0 * a.e2 : undefined,\r\n        e02: a.e1 !== undefined ? -1.0 * a.e1 : undefined,\r\n        e12: a.e0 !== undefined ? 1.0 * a.e0 : undefined,\r\n        e012: a.scalar !== undefined ? 1.0 * a.scalar : undefined,\r\n    }\r\n    return result as DualResultType<A>\r\n}\r\n\r\nexport type GeometricProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE2 ? BladeE12 : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {}) &\r\n        (B extends BladeE02 ? BladeE012 : {}) &\r\n        (B extends BladeE12 ? BladeE2 : {}) &\r\n        (B extends BladeE012 ? BladeE02 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE0 ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE12 : {}) &\r\n        (B extends BladeE2 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE012 : {}) &\r\n        (B extends BladeE02 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE1 : {}) &\r\n        (B extends BladeE012 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {}) &\r\n        (B extends BladeE2 ? BladeE012 : {}) &\r\n        (B extends BladeE12 ? BladeE02 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE012 : {}) &\r\n        (B extends BladeE2 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE0 ? BladeE012 : {}) &\r\n        (B extends BladeE1 ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeE1 : {}) &\r\n        (B extends BladeE01 ? BladeE02 : {}) &\r\n        (B extends BladeE02 ? BladeE01 : {}) &\r\n        (B extends BladeE12 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {}) &\r\n        (B extends BladeE1 ? BladeE02 : {}) &\r\n        (B extends BladeE2 ? BladeE01 : {}) &\r\n        (B extends BladeE12 ? BladeE0 : {})\r\n    ) : {})\r\n\r\nexport const geometricProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): GeometricProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_2 = a.e2 !== undefined && b.e2 !== undefined\r\n    const scalar_3 = a.e12 !== undefined && b.e12 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e2! * b.e2!)\r\n        if (scalar_3) resultScalar += -1.0 * (a.e12! * b.e12!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e2 !== undefined && b.e02 !== undefined\r\n    const e0_4 = a.e01 !== undefined && b.e1 !== undefined\r\n    const e0_5 = a.e02 !== undefined && b.e2 !== undefined\r\n    const e0_6 = a.e12 !== undefined && b.e012 !== undefined\r\n    const e0_7 = a.e012 !== undefined && b.e12 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3 || e0_4 || e0_5 || e0_6 || e0_7) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += -1.0 * (a.e2! * b.e02!)\r\n        if (e0_4) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n        if (e0_5) resultE0 += 1.0 * (a.e02! * b.e2!)\r\n        if (e0_6) resultE0 += -1.0 * (a.e12! * b.e012!)\r\n        if (e0_7) resultE0 += -1.0 * (a.e012! * b.e12!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_2 = a.e2 !== undefined && b.e12 !== undefined\r\n    const e1_3 = a.e12 !== undefined && b.e2 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_2) resultE1 += -1.0 * (a.e2! * b.e12!)\r\n        if (e1_3) resultE1 += 1.0 * (a.e12! * b.e2!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e1 !== undefined && b.e12 !== undefined\r\n    const e2_2 = a.e2 !== undefined && b.scalar !== undefined\r\n    const e2_3 = a.e12 !== undefined && b.e1 !== undefined\r\n    if (e2_0 || e2_1 || e2_2 || e2_3) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e1! * b.e12!)\r\n        if (e2_2) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n        if (e2_3) resultE2 += -1.0 * (a.e12! * b.e1!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e2 !== undefined && b.e012 !== undefined\r\n    const e01_4 = a.e01 !== undefined && b.scalar !== undefined\r\n    const e01_5 = a.e02 !== undefined && b.e12 !== undefined\r\n    const e01_6 = a.e12 !== undefined && b.e02 !== undefined\r\n    const e01_7 = a.e012 !== undefined && b.e2 !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3 || e01_4 || e01_5 || e01_6 || e01_7) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e2! * b.e012!)\r\n        if (e01_4) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n        if (e01_5) resultE01 += -1.0 * (a.e02! * b.e12!)\r\n        if (e01_6) resultE01 += 1.0 * (a.e12! * b.e02!)\r\n        if (e01_7) resultE01 += 1.0 * (a.e012! * b.e2!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e0 !== undefined && b.e2 !== undefined\r\n    const e02_2 = a.e1 !== undefined && b.e012 !== undefined\r\n    const e02_3 = a.e2 !== undefined && b.e0 !== undefined\r\n    const e02_4 = a.e01 !== undefined && b.e12 !== undefined\r\n    const e02_5 = a.e02 !== undefined && b.scalar !== undefined\r\n    const e02_6 = a.e12 !== undefined && b.e01 !== undefined\r\n    const e02_7 = a.e012 !== undefined && b.e1 !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3 || e02_4 || e02_5 || e02_6 || e02_7) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += 1.0 * (a.e0! * b.e2!)\r\n        if (e02_2) resultE02 += -1.0 * (a.e1! * b.e012!)\r\n        if (e02_3) resultE02 += -1.0 * (a.e2! * b.e0!)\r\n        if (e02_4) resultE02 += 1.0 * (a.e01! * b.e12!)\r\n        if (e02_5) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n        if (e02_6) resultE02 += -1.0 * (a.e12! * b.e01!)\r\n        if (e02_7) resultE02 += -1.0 * (a.e012! * b.e1!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e1 !== undefined && b.e2 !== undefined\r\n    const e12_2 = a.e2 !== undefined && b.e1 !== undefined\r\n    const e12_3 = a.e12 !== undefined && b.scalar !== undefined\r\n    if (e12_0 || e12_1 || e12_2 || e12_3) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e1! * b.e2!)\r\n        if (e12_2) resultE12 += -1.0 * (a.e2! * b.e1!)\r\n        if (e12_3) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e0 !== undefined && b.e12 !== undefined\r\n    const e012_2 = a.e1 !== undefined && b.e02 !== undefined\r\n    const e012_3 = a.e2 !== undefined && b.e01 !== undefined\r\n    const e012_4 = a.e01 !== undefined && b.e2 !== undefined\r\n    const e012_5 = a.e02 !== undefined && b.e1 !== undefined\r\n    const e012_6 = a.e12 !== undefined && b.e0 !== undefined\r\n    const e012_7 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1 || e012_2 || e012_3 || e012_4 || e012_5 || e012_6 || e012_7) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e0! * b.e12!)\r\n        if (e012_2) resultE012 += -1.0 * (a.e1! * b.e02!)\r\n        if (e012_3) resultE012 += 1.0 * (a.e2! * b.e01!)\r\n        if (e012_4) resultE012 += 1.0 * (a.e01! * b.e2!)\r\n        if (e012_5) resultE012 += -1.0 * (a.e02! * b.e1!)\r\n        if (e012_6) resultE012 += 1.0 * (a.e12! * b.e0!)\r\n        if (e012_7) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as GeometricProductResultType<A, B>\r\n}\r\n\r\nexport type InnerProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE2 : {}) &\r\n        (B extends BladeE012 ? BladeE02 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeScalar : {}) &\r\n        (B extends BladeE02 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE1 : {}) &\r\n        (B extends BladeE012 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE2 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE1 ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeE1 : {}) &\r\n        (B extends BladeE12 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {}) &\r\n        (B extends BladeE1 ? BladeE02 : {}) &\r\n        (B extends BladeE2 ? BladeE01 : {}) &\r\n        (B extends BladeE12 ? BladeE0 : {})\r\n    ) : {})\r\n\r\nexport const innerProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): InnerProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_2 = a.e2 !== undefined && b.e2 !== undefined\r\n    const scalar_3 = a.e12 !== undefined && b.e12 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e2! * b.e2!)\r\n        if (scalar_3) resultScalar += -1.0 * (a.e12! * b.e12!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e2 !== undefined && b.e02 !== undefined\r\n    const e0_4 = a.e01 !== undefined && b.e1 !== undefined\r\n    const e0_5 = a.e02 !== undefined && b.e2 !== undefined\r\n    const e0_6 = a.e12 !== undefined && b.e012 !== undefined\r\n    const e0_7 = a.e012 !== undefined && b.e12 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3 || e0_4 || e0_5 || e0_6 || e0_7) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += -1.0 * (a.e2! * b.e02!)\r\n        if (e0_4) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n        if (e0_5) resultE0 += 1.0 * (a.e02! * b.e2!)\r\n        if (e0_6) resultE0 += -1.0 * (a.e12! * b.e012!)\r\n        if (e0_7) resultE0 += -1.0 * (a.e012! * b.e12!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_2 = a.e2 !== undefined && b.e12 !== undefined\r\n    const e1_3 = a.e12 !== undefined && b.e2 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_2) resultE1 += -1.0 * (a.e2! * b.e12!)\r\n        if (e1_3) resultE1 += 1.0 * (a.e12! * b.e2!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e1 !== undefined && b.e12 !== undefined\r\n    const e2_2 = a.e2 !== undefined && b.scalar !== undefined\r\n    const e2_3 = a.e12 !== undefined && b.e1 !== undefined\r\n    if (e2_0 || e2_1 || e2_2 || e2_3) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e1! * b.e12!)\r\n        if (e2_2) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n        if (e2_3) resultE2 += -1.0 * (a.e12! * b.e1!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e2 !== undefined && b.e012 !== undefined\r\n    const e01_2 = a.e01 !== undefined && b.scalar !== undefined\r\n    const e01_3 = a.e012 !== undefined && b.e2 !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e2! * b.e012!)\r\n        if (e01_2) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e012! * b.e2!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e1 !== undefined && b.e012 !== undefined\r\n    const e02_2 = a.e02 !== undefined && b.scalar !== undefined\r\n    const e02_3 = a.e012 !== undefined && b.e1 !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += -1.0 * (a.e1! * b.e012!)\r\n        if (e02_2) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n        if (e02_3) resultE02 += -1.0 * (a.e012! * b.e1!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e12 !== undefined && b.scalar !== undefined\r\n    if (e12_0 || e12_1) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as InnerProductResultType<A, B>\r\n}\r\n\r\nexport type ExteriorProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE12 : {}) &\r\n        (B extends BladeE02 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE0 ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE12 : {}) &\r\n        (B extends BladeE01 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE0 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {})\r\n    ) : {})\r\n\r\nexport const exteriorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): ExteriorProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    if (scalar_0) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    if (e0_0 || e0_1) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e1 !== undefined && b.scalar !== undefined\r\n    if (e1_0 || e1_1) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e2 !== undefined && b.scalar !== undefined\r\n    if (e2_0 || e2_1) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e01 !== undefined && b.scalar !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e0 !== undefined && b.e2 !== undefined\r\n    const e02_2 = a.e2 !== undefined && b.e0 !== undefined\r\n    const e02_3 = a.e02 !== undefined && b.scalar !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += 1.0 * (a.e0! * b.e2!)\r\n        if (e02_2) resultE02 += -1.0 * (a.e2! * b.e0!)\r\n        if (e02_3) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e1 !== undefined && b.e2 !== undefined\r\n    const e12_2 = a.e2 !== undefined && b.e1 !== undefined\r\n    const e12_3 = a.e12 !== undefined && b.scalar !== undefined\r\n    if (e12_0 || e12_1 || e12_2 || e12_3) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e1! * b.e2!)\r\n        if (e12_2) resultE12 += -1.0 * (a.e2! * b.e1!)\r\n        if (e12_3) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e0 !== undefined && b.e12 !== undefined\r\n    const e012_2 = a.e1 !== undefined && b.e02 !== undefined\r\n    const e012_3 = a.e2 !== undefined && b.e01 !== undefined\r\n    const e012_4 = a.e01 !== undefined && b.e2 !== undefined\r\n    const e012_5 = a.e02 !== undefined && b.e1 !== undefined\r\n    const e012_6 = a.e12 !== undefined && b.e0 !== undefined\r\n    const e012_7 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1 || e012_2 || e012_3 || e012_4 || e012_5 || e012_6 || e012_7) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e0! * b.e12!)\r\n        if (e012_2) resultE012 += -1.0 * (a.e1! * b.e02!)\r\n        if (e012_3) resultE012 += 1.0 * (a.e2! * b.e01!)\r\n        if (e012_4) resultE012 += 1.0 * (a.e01! * b.e2!)\r\n        if (e012_5) resultE012 += -1.0 * (a.e02! * b.e1!)\r\n        if (e012_6) resultE012 += 1.0 * (a.e12! * b.e0!)\r\n        if (e012_7) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as ExteriorProductResultType<A, B>\r\n}\r\n\r\nexport const multiply = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar * b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 * b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 * b : undefined,\r\n        e2: a.e2 !== undefined ? a.e2 * b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 * b : undefined,\r\n        e02: a.e02 !== undefined ? a.e02 * b : undefined,\r\n        e12: a.e12 !== undefined ? a.e12 * b : undefined,\r\n        e012: a.e012 !== undefined ? a.e012 * b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const div = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar / b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 / b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 / b : undefined,\r\n        e2: a.e2 !== undefined ? a.e2 / b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 / b : undefined,\r\n        e02: a.e02 !== undefined ? a.e02 / b : undefined,\r\n        e12: a.e12 !== undefined ? a.e12 / b : undefined,\r\n        e012: a.e012 !== undefined ? a.e012 / b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const reversion = <A extends OptionalMultiVector>(a: A): A => {\r\n    const result: any = {\r\n        scalar: a.scalar && a.scalar,\r\n        e0: a.e0 && a.e0,\r\n        e1: a.e1 && a.e1,\r\n        e2: a.e2 && a.e2,\r\n        e01: a.e01 && -a.e01,\r\n        e02: a.e02 && -a.e02,\r\n        e12: a.e12 && -a.e12,\r\n        e012: a.e012 && -a.e012,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const repr = <A extends OptionalMultiVector>(a: A, digits: number = 3): string => {\r\n    let result = \"\"\r\n    if (a.scalar !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.scalar.toFixed(digits) + \"\"\r\n        } else {\r\n            result += a.scalar >= 0 ? \" + \" + a.scalar.toFixed(digits) + \"\" : \" - \" + Math.abs(a.scalar).toFixed(digits) + \"\"\r\n        }\r\n    }\r\n    if (a.e0 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e0.toFixed(digits) + \"e0\"\r\n        } else {\r\n            result += a.e0 >= 0 ? \" + \" + a.e0.toFixed(digits) + \"e0\" : \" - \" + Math.abs(a.e0).toFixed(digits) + \"e0\"\r\n        }\r\n    }\r\n    if (a.e1 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e1.toFixed(digits) + \"e1\"\r\n        } else {\r\n            result += a.e1 >= 0 ? \" + \" + a.e1.toFixed(digits) + \"e1\" : \" - \" + Math.abs(a.e1).toFixed(digits) + \"e1\"\r\n        }\r\n    }\r\n    if (a.e2 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e2.toFixed(digits) + \"e2\"\r\n        } else {\r\n            result += a.e2 >= 0 ? \" + \" + a.e2.toFixed(digits) + \"e2\" : \" - \" + Math.abs(a.e2).toFixed(digits) + \"e2\"\r\n        }\r\n    }\r\n    if (a.e01 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e01.toFixed(digits) + \"e01\"\r\n        } else {\r\n            result += a.e01 >= 0 ? \" + \" + a.e01.toFixed(digits) + \"e01\" : \" - \" + Math.abs(a.e01).toFixed(digits) + \"e01\"\r\n        }\r\n    }\r\n    if (a.e02 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e02.toFixed(digits) + \"e02\"\r\n        } else {\r\n            result += a.e02 >= 0 ? \" + \" + a.e02.toFixed(digits) + \"e02\" : \" - \" + Math.abs(a.e02).toFixed(digits) + \"e02\"\r\n        }\r\n    }\r\n    if (a.e12 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e12.toFixed(digits) + \"e12\"\r\n        } else {\r\n            result += a.e12 >= 0 ? \" + \" + a.e12.toFixed(digits) + \"e12\" : \" - \" + Math.abs(a.e12).toFixed(digits) + \"e12\"\r\n        }\r\n    }\r\n    if (a.e012 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e012.toFixed(digits) + \"e012\"\r\n        } else {\r\n            result += a.e012 >= 0 ? \" + \" + a.e012.toFixed(digits) + \"e012\" : \" - \" + Math.abs(a.e012).toFixed(digits) + \"e012\"\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nexport const regressiveProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    dual(exteriorProduct(dual(a), dual(b)))\r\n\r\nexport const sandwichProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    geometricProduct(b, geometricProduct(a, reversion(b)))\r\n\r\nexport const commutatorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    multiply(sub(geometricProduct(a, b), geometricProduct(b, a)), 0.5)\r\n\r\nexport const exponential = <A extends OptionalMultiVector>(a: A) => {\r\n    const gp = geometricProduct(a, a) as any\r\n    const s = gp.scalar || 0\r\n\r\n    // TODO: Check if non-scalar parts are non-zero\r\n\r\n    if (s < 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cos(rootS) }, multiply(a, Math.sin(rootS) / rootS))\r\n    } else if (s > 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cosh(rootS) }, multiply(a, Math.sinh(rootS) / rootS))\r\n    } else {\r\n        return add({ scalar: 1 }, a)\r\n    }\r\n}","import { useEffect } from \"react\"\r\n\r\nexport function useMathJax() {\r\n    // Need to retrigger equation typesetting as it's only done once on startup\r\n    useEffect(() => {\r\n        // eslint-disable-next-line no-eval\r\n        eval(\"if (MathJax && MathJax.typeset) { MathJax.texReset(); MathJax.typeset(); }\")\r\n    }, [])\r\n}\r\n\r\nexport function ImageWithSub(props: { src: string, text: string, width?: string }) {\r\n    const { src, text, width } = props\r\n    return (\r\n        <div style={{ padding: 20, textAlign: \"center\" }}>\r\n            <div>\r\n                <img src={src} alt={text} style={{ width: width ?? \"100%\" }} />\r\n            </div>\r\n            <sub>{text}</sub>\r\n        </div>\r\n    )\r\n}","import React, { useEffect } from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub } from \"../util\"\r\n\r\nexport function SRTimeDilation() {\r\n    // Need to retrigger equation typesetting as it's only done once on startup\r\n    useEffect(() => {\r\n        // eslint-disable-next-line no-eval\r\n        eval(\"if (MathJax && MathJax.typeset) { MathJax.texReset(); MathJax.typeset(); }\")\r\n    }, [])\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Time Dilation</h3>\r\n            <h4>Measuring a time difference</h4>\r\n            <ImageWithSub src=\"/images/sr-time-dilation.png\" width=\"60%\" text=\"Light blue: Alice's basis vectors. Teal: Bob's basis vectors. Purple: Rotor from Alice's to Bob's basis vectors. Orange: Stop event vector. Yellow: Time difference between start and stop event.\" />\r\n            <div>\r\n                <u style={{ textDecorationColor: \"#0095FF\", textDecorationThickness: 3 }}>Alice</u> is standing still with a stopwatch at x coordinate $0$. She starts her stopwatch at time $0$ and\r\n                stops it at <u style={{ textDecorationColor: \"gold\", textDecorationThickness: 3 }}>time $\\Delta t$</u>.\r\n                The <u style={{ textDecorationColor: \"orange\", textDecorationThickness: 3 }}>difference vector $v$</u> is the same as the stop event vector because we defined the start event vector to be at zero.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                v = c \\\\Delta t e_t \\\\\\\\\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Alice can measure the stop event components using her reciprocal basis vector:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                e^x \\\\cdot v = & e^x \\\\cdot c \\\\Delta t e_t = 0 \\\\\\\\\r\n                e^t \\\\cdot v = & e^t \\\\cdot c \\\\Delta t e_t = c \\\\Delta t\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                So far so good, nothing unexpected has happened. Now we have Bob who is moving with constant speed along the x direction.\r\n                <u style={{ textDecorationColor: \"#00FFFF\", textDecorationThickness: 3 }}>Bob's basis vectors</u>, indicated with a prime, are obtained by\r\n                applying a <u style={{ textDecorationColor: \"purple\", textDecorationThickness: 3 }}>rotor $R$</u> to Alice's basis vectors.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                R = e^{-\\\\frac{\\\\varphi}{2} e_{tx}} \\\\\\\\\r\n                e_t' = R e_t \\\\widetilde{R} \\\\\\\\\r\n                e_x' = R e_x \\\\widetilde{R}\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Bob then looks at Alice start and stop her stopwatch. To figure out when and where the stop event happens for Bob, he uses his reciprocal basis vectors and takes the inner product\r\n                with the stop event. Because Bob performed a passive transformation, we expect that he will measure different components than Alice, but we know that the thing being measured\r\n                did not actually change.\r\n            </div>\r\n            <div>\r\n                For the time component Bob measures the following\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                c \\\\Delta t' & = {e^t}' \\\\cdot v = R e^t \\\\widetilde{R} \\\\cdot v = R e_t \\\\widetilde{R} \\\\cdot v \\\\\\\\\r\n                & = (cosh(\\\\varphi) e_t + sinh(\\\\varphi) e_x) \\\\cdot c \\\\Delta t e_t \\\\\\\\\r\n                & = cosh(\\\\varphi) c \\\\Delta t\r\n                \\\\end{aligned}\r\n                \\\\label{eq:time-dilation}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Because $cosh(\\varphi) \\geq 1$, the faster Bob moves, the longer it takes for him to see the stop event. Bob sees Alice's clock ticking slower.\r\n                This is a phenomenon called time dilation. An observer moving relative to another observer will see the other's time tick slower.\r\n            </div>\r\n            <div>\r\n                We can now also look at w here Bob will see the stop event happen. We will call the x coordinate of the stop event as seen by Bob $\\Delta x'$.\r\n                Recall that Alice stood still the entire time, so for her $\\Delta x = 0$.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                \\\\Delta x' & = {e^x}' \\\\cdot v = R e^x \\\\widetilde{R} \\\\cdot v = -R e_x \\\\widetilde{R} \\\\cdot v\\\\\\\\\r\n                & = -(cosh(\\\\varphi) e_x + sinh(\\\\varphi) e_t) \\\\cdot c \\\\Delta t e_t \\\\\\\\\r\n                & = -sinh(\\\\varphi) c \\\\Delta t\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                In Bob's view, the stop event happens in the negative x direction. This makes intuitive sense because Bob is moving in the positive x direction,\r\n                so of course he will have left the \"stationary\" stop event behind him in the opposite direction.\r\n                Importantly though, the offset we arrived at here is still not just the non-relativistic offset of {`$\\\\mathrm{speed} \\\\times \\\\mathrm{time}$`}.\r\n            </div>\r\n            <h4>Numeric example</h4>\r\n            <div>\r\n                Let's plug in some example values, for {`$\\\\Delta t = 10\\\\mathrm{s}$`} (ie. Alice stopping the stopwatch after it shows 10 seconds for her) and Bob moving at $0.9c$ we get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                \\\\varphi & = tanh^{-1}(\\\\frac{0.9c}{c}) \\\\\\\\\r\n                \\\\Delta t' & = cosh(\\\\varphi) \\\\Delta t \\\\approx 23\\\\mathrm{s} \\\\\\\\\r\n                \\\\Delta x' & = -sinh(\\\\varphi) c \\\\Delta t \\\\approx -6.2 \\\\times 10^9\\\\mathrm{m} \\\\approx -21 \\\\mathrm{light seconds}\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                For comparison, just using {`$0.9c \\\\times 10 \\\\mathrm{s}$`} for the x offset Bob sees would give {`$-2.7 \\\\times 10^9 \\\\mathrm{m} = -9 \\\\mathrm{light seconds}$`}, less than half the actual offset.\r\n            </div>\r\n            <h4>Gamma factor</h4>\r\n            <div>\r\n                We can rearrange {`\\\\eqref{eq:time-dilation}`} for the ratio of the dilated and the original time, and substitute $\\varphi$ using its velocity relation {`$tanh \\\\varphi = \\\\frac{v}{c}$`} to get the following equation\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\frac{\\\\Delta t'}{\\\\Delta t} = cosh(\\\\varphi) = cosh(tanh^{-1}(\\\\frac{v}{c}))\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                In ordinary Special Relativity the ratio we arrived is called the <a href=\"https://en.wikipedia.org/wiki/Lorentz_factor\">Gamma factor or Lorentz factor</a> {`$\\\\gamma = \\\\frac{1}{\\\\sqrt{1 - \\\\frac{v^2}{c^2}}}$`}.\r\n                and is used all over the place there. However the expression we have right now involves hyperbolic functions does not look exactly like the gamma factor yet.\r\n                To bring it into the same form, we use the identity {`$cosh(tanh^{-1}(x)) = \\\\frac{1}{\\\\sqrt{1 - x^2}}$`}.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\frac{\\\\Delta t'}{\\\\Delta t} = cosh(tanh^{-1}(\\\\frac{v}{c})) = \\\\frac{1}{\\\\sqrt{1 - \\\\frac{v^2}{c^2}}} = \\\\gamma\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The gamma factor is $1$ at rest, and goes up with the relative velocity.\r\n            </div>\r\n\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                First we saw that we can change between reference frames (ie. basis vectors of different observers) using rotors.\r\n                Then we looked at a length in a rest frame and at how the length is seen by an observer moving relative to it.\r\n                We noticed for length measurements it is important to measure both endpoints at the same time in the measurer's frame.\r\n                The length ratio we arrived at was the Gamma factor which varies between $1$ and $0$ as the relative speed goes up.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Gamma factor for observer moving with velocity $v$: {`$\\\\gamma(v) = cosh(tanh^{-1}(\\\\frac{v}{c})) = \\\\frac{1}{\\\\sqrt{1 - \\\\frac{v^2}{c^2}}}$`}</li>\r\n                    <li>Time dilation for observer moving with relative velocity $v$: {`$\\\\frac{\\\\Delta t'}{\\\\Delta t} = \\\\gamma(v)$`}</li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Next we will look at how a moving observer sees lengths change.\r\n            </div>\r\n\r\n            <h4><Link to=\"/sr-length-contraction\">Special Relativity with Geometric Algebra - Length Contraction</Link></h4>\r\n        </div>\r\n    )\r\n}","import React, { useEffect } from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub } from \"../util\"\r\n\r\nexport function SRLengthContraction() {\r\n    // Need to retrigger equation typesetting as it's only done once on startup\r\n    useEffect(() => {\r\n        // eslint-disable-next-line no-eval\r\n        eval(\"if (MathJax && MathJax.typeset) { MathJax.texReset(); MathJax.typeset(); }\")\r\n    }, [])\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Length Contraction</h3>\r\n            <div>\r\n                In the previous section we saw how clocks tick slower for observers looking at clocks that are in motion relative to them. In this section we will look at what happens to lengths\r\n                for observers moving relative to them.\r\n            </div>\r\n            <div>\r\n                This section is based on <a href=\"https://www.youtube.com/channel/UCN8wTUlSAroLslWyf87E2pw\">Eigenchris'</a> video \"Relativity 104c: Special Relativity - Time Dilation and Length Contraction Geometry\"\r\n                and the length contraction part is discussed at <a href=\"https://www.youtube.com/watch?v=WOLUSQK1Jtk&amp;t=1347s\">this part</a>. If you have trouble following the text here it is\r\n                worth watching the length contraction part of the video.\r\n            </div>\r\n            <h4>Length Contraction</h4>\r\n            <div>\r\n                Imagine <u style={{ textDecorationColor: \"lightblue\", textDecorationThickness: 3 }}>Alice</u> is standing still and is looking at a fixed-length object at rest with her,\r\n                for example a <u style={{ textDecorationColor: \"red\", textDecorationThickness: 3 }}>stick</u>.\r\n                How does Alice measure the length (the x extent) of the stick? She calculates the difference vector from the first to the second endpoint and takes the inner product with her reciprocal basis vector $e^x$.\r\n                What is very important here: the endpoints are not separated in her time axis! She is only measuring a spatial distance and the time for both endpoints is the same.\r\n            </div>\r\n            <div>\r\n                <u style={{ textDecorationColor: \"purple\", textDecorationThickness: 3 }}>Bob</u> is moving relative to Alice.\r\n                We have a passive transformation between Alice's and Bob's basis vectors using a <u style={{ textDecorationColor: \"pink\", textDecorationThickness: 3 }}>rotor $R$</u>.\r\n            </div>\r\n            <div>\r\n                The diagram below pictures our setup.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-lengthcontraction-1.png\" text=\"Figure 2 - Blue: Alice's frame / basis vectors. Red: Stationary stick with length l. Purple: Bob's frame / basis vectors. Pink: Rotor from Alice's to Bob's frame.\" width=\"50%\" />\r\n            <div>\r\n                So both of <u style={{ textDecorationColor: \"purple\", textDecorationThickness: 3 }}>Bob's basis vectors</u> are a bit tilted compared to <u style={{ textDecorationColor: \"lightblue\", textDecorationThickness: 3 }}>Alice's</u>.\r\n                How does Bob see the measuring stick? If we try measuring the <u style={{ textDecorationColor: \"red\", textDecorationThickness: 3 }}>stick's difference vector</u> with Bob's reciprocal basis vectors,\r\n                such as in the previous section, we will run into an issue:\r\n            </div>\r\n            <div>\r\n                The stick expressed in terms of Bob's basis vectors has both a time and space component, as the stick is not parallel to either of his basis vectors.\r\n                In Bob's view, the endpoints of the original stick are at different times and measuring this difference vector would not make sense as we would be measuring both a distance in space as well as a distance in time.\r\n            </div>\r\n            <div>\r\n                To remedy this we need to draw a line in Bob's frame along which events occur at the same moment in time.\r\n                For that we notice that all events on lines parallel to Bob's spatial basis vector {`$e_x^{(b)}$`} occur at the same time because {`$ {e^t}^{(b)} \\\\cdot e_x^{(b)} = 0$`},\r\n                meaning Bob's time measurement does not change along the line in Bob's x direction. They are called lines of simultaneity as events on them occur at the same time.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-lengthcontraction-2.png\" text=\"Figure 3 - Orange: Stick along Bob's lines of simultaneity. The yellow and brown lines can be expressed in Alice's frame and relate to the orange line.\" width=\"50%\" />\r\n            <div>\r\n                The <u style={{ textDecorationColor: \"orange\", textDecorationThickness: 3 }}>orange vector</u> in the drawing is a line of simultaneity because it is parallel to Bob's {`$e_x^{(b)}$`} basis vector.\r\n                The {`$e_x^{(b)}$`} component of it in Bob's view is what we actually want to measure.\r\n            </div>\r\n            <div>\r\n                We then observe that the <u style={{ textDecorationColor: \"gold\", textDecorationThickness: 3 }}>yellow vector with known $l$</u> plus\r\n                the <u style={{ textDecorationColor: \"#C4A484\", textDecorationThickness: 3 }}>brown vector with unknown $d$</u> can be expressed\r\n                with <u style={{ textDecorationColor: \"lightblue\", textDecorationThickness: 3 }}>Alice's basis vectors</u> and\r\n                must equal the <u style={{ textDecorationColor: \"orange\", textDecorationThickness: 3 }}>orange vector</u> we're looking for which is expressed\r\n                with <u style={{ textDecorationColor: \"purple\", textDecorationThickness: 3 }}>Bob's basis vectors</u>.\r\n                So we can write\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    l e_x^{(a)} + d e_t^{(a)} = l^{(b)} e_x^{(b)}\r\n                    \\\\label{eq:lengthcontraction1}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We can express Bob's spatial basis vector in terms of Alice's basis vector using the rotor $R$ in the opposite direction, ie. {`$\\\\widetilde{R}$`}.\r\n                Doing this, expanding the rotor's exponential and simplifying yields\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    \\\\begin{aligned}\r\n                        l^{(b)} e_x^{(b)} & = l^{(b)} \\\\widetilde{R} e_x^{(b)} {R} = l^{(b)} (cosh(\\\\varphi) e_x^{(a)} + sinh(\\\\varphi) e_t^{(a)})\r\n                    \\\\end{aligned}\r\n                    \\\\label{eq:lengthcontraction2}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Putting together {`\\\\eqref{eq:lengthcontraction1}`} and {`\\\\eqref{eq:lengthcontraction2}`} we get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    l e_x^{(a)} + d e_t^{(a)} = l^{(b)} (cosh(\\\\varphi) e_x^{(a)} + sinh(\\\\varphi) e_t^{(a)})\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                If we now only look at the spatial {`$e_x^{(a)}$`} components of both sides we are left with\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    l = l^{(b)} cosh(\\\\varphi)\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Let's solve this for the ratio between Bob's and Alice's lengths\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    \\\\frac{l^{(b)}}{l} = \\\\frac{1}{cosh(\\\\varphi)}\r\n                    \\\\label{eq:lengthcontraction3}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Because the hyperbolic cosine function is always greater or equal to $1$, the right hand side is always less than or equal to $1$.\r\n                This means that Bob, who is moving relative to the stick, always sees the length as shorter than Alice, who is at rest relative to the stick.\r\n            </div>\r\n            <div>\r\n                A observer sees lengths in relative motion shorter than lengths at rest. This is called length contraction.\r\n                Let's substitute $\\varphi$ in {`\\\\eqref{eq:lengthcontraction3}`} with the velocity to get the relation between the velocity and the fraction of the length seen by a moving observer\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\frac{l^{(b)}}{l} = \\\\frac{1}{cosh(tanh^{-1}(\\\\frac{v}{c}))}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Evaluating this for $v = 0.9c$ we get around 44%. So an observer moving at 90% of the speed of light would see the stick at 44% of its original length at rest.\r\n                Here's a plot of the relation and the value we just got.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-lengthcontraction-3.png\" text=\"Figure 3 - Orange: Stick along Bob's lines of simultaneity. The yellow and brown lines can be expressed in Alice's frame and relate to the orange line.\" width=\"50%\" />\r\n            <div>\r\n                The ratio starts at $1$ and, as the velocity gets closer to the speed of light, the ratio shrinks to $0$. The effects start off slow and get more dramatic towards the speed of light.\r\n            </div>\r\n            <h4>Gamma factor</h4>\r\n            <div>\r\n                To relate with the ordinary formalism, we can also write our results in terms of the gamma factor again:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\frac{l'}{l} = \\\\frac{1}{cosh(tanh^{-1}(\\\\frac{v}{c}))} = \\\\sqrt{1 - \\\\frac{v^2}{c^2}} = \\\\frac{1}{\\\\gamma}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We looked at a length in a rest frame and at how the length is seen by an observer moving relative to it.\r\n                We noticed for length measurements it is important to measure both endpoints at the same time in the measurer's frame.\r\n                The length ratio we arrived at varies between $1$ and $0$ as the relative speed goes up.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Lines of simultaneity: {`$e^t \\\\cdot v = 0$`}</li>\r\n                    <li>Length contraction for observer moving with relative velocity $v$: {`$\\\\frac{l'}{l} = \\\\frac{1}{\\\\gamma(v)}$`}</li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Next we will look at how a moving observer sees an electric field in electromagnetics.\r\n            </div>\r\n            <h4><Link to=\"/sr-electromagnetism\">Special Relativity with Geometric Algebra - Electromagnetism</Link></h4>\r\n        </div>\r\n    )\r\n}","import React, { useEffect } from \"react\"\r\nimport { ImageWithSub } from \"../util\"\r\n\r\nexport function SRElectromagnetism() {\r\n    // Need to retrigger equation typesetting as it's only done once on startup\r\n    useEffect(() => {\r\n        // eslint-disable-next-line no-eval\r\n        eval(\"if (MathJax && MathJax.typeset) { MathJax.texReset(); MathJax.typeset(); }\")\r\n    }, [])\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Electromagnetism</h3>\r\n            <div>\r\n                Electromagnetism is most often described using Maxwell's equations in vector form.\r\n                In Geometric Algebra these can be expressed as a single equation and a field that unifies the electric and magnetic fields.\r\n                This also makes it very easy to combine our results from Special Relativity with Electromagnetism.\r\n            </div>\r\n            <div>\r\n                There are already a lot of resources showing how to do Electromagnetism with GA. Here are a couple of short ones that get the essence if you are interested:\r\n                <ul>\r\n                    <li><a href=\"https://www.av8n.com/physics/maxwell-ga.htm\">av8n</a> article</li>\r\n                    <li>Last part of <a href=\"https://youtu.be/60z_hpEAtD8?t=2138\">A Swift Introduction to Geometric Algebra</a> by Sudgy</li>\r\n                </ul>\r\n\r\n                For now we actually won't use any of Maxwell's equations. The relevant part to us is that the electric and magnetic fields will be bivector fields $E$ and $B$ using the bivectors that\r\n                square to $+1$ ({`$e_{tx}, e_{ty}, e_{tz}$`} corresponding to each direction in space) and that they can be combined into a single bivector field $F$ called the Faraday field in the following way:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                F = E + I B\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Because the magnetic bivector field is multiplied by the pseudoscalar $I$, in general $F$ contains all bivectors in the algebra.\r\n            </div>\r\n            <div>\r\n                In the next part we will investigate an electric field as seen\r\n                by an observer moving orthogonal to it.\r\n            </div>\r\n            <h4>Electric field seen by observer moving orthogonal to it</h4>\r\n            <ImageWithSub src=\"/images/sr-efield-movingobs.png\" text=\"Figure 1 - Blue: Rest frame. Purple: Moving observer's frame. Red: Electric field in x direction of rest frame. Pink: Rotor from rest frame to moving observer's frame.\" width=\"60%\" />\r\n            <div>\r\n                Let's start with an <u style={{textDecorationColor: \"red\", textDecorationThickness: 3}}>electric field $E$</u> with only a value $E_x$ in the $x$ direction\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                F = E = E_x e_{tx}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The basis vectors for an observer moving relative to the field with rapidity $\\varphi_y$ in the $y$ direction can be obtained with a passive transformation\r\n                by applying a rotor to the basis vectors at rest.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                R_y(\\\\varphi_y) = e^{-\\\\frac{\\\\varphi_y}{2} e_{ty}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The <u style={{textDecorationColor: \"pink\", textDecorationThickness: 3}}>rotor $R_y$</u> transforms from the <u style={{textDecorationColor: \"blue\", textDecorationThickness: 3}}>rest frame</u> to\r\n                the <u style={{textDecorationColor: \"purple\", textDecorationThickness: 3}}>moving observer's frame</u>. We can now measure the field with the reciprocal basis vectors of the moving frame\r\n                to figure out how a moving observer sees the field.\r\n            </div>\r\n            <div>\r\n                Before continuing with the algebra, let's take another look at the diagram. What would we expect to happen if we applied the rotor to the field?\r\n                The bivector field lies in the TX plane. The rotor (hyperbolically) rotates between the T and the Y axis.\r\n                So we would expect the resulting bivector field to have not only have a TX component but also an XY component.\r\n            </div>\r\n            <div>\r\n                We can also see this visually: the original XY plane was orthogonal to $E$'s plane, but the XY' plane is not orthogonal anymore.\r\n            </div>\r\n            <h5>Reciprocal basis bivectors</h5>\r\n            <div>\r\n                Okay now for the algebra: because we are measuring bivectors and not vectors, we want to build reciprocal bivectors.\r\n                For example to measure the XY component, we have a basis bivector {`$e_{xy}$`} and its corresponding reciprocal basis bivector is\r\n                {`$e^{xy} = -e_{xy}$`} because {`$-e_{xy} \\\\cdot e_{xy} = 1$`}.\r\n            </div>\r\n            <div>\r\n                We already established that the moving observer should see a field in the TX and the XY plane, so let's build the reciprocal\r\n                basis bivectors for those.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                {e^{tx}}' & = R_y {e^{tx}} \\\\widetilde{R}_y = R_y e_{tx} \\\\widetilde{R}_y = cosh(\\\\varphi_y) e_{tx} + sinh(\\\\varphi) e_{xy} \\\\\\\\\r\n                {e^{xy}}' & = R_y {e^{xy}} \\\\widetilde{R}_y = -R_y e_{xy} \\\\widetilde{R}_y = -(cosh(\\\\varphi_y) e_{xy} + sinh(\\\\varphi) e_{tx})\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Field measured by orthogonally moving observer</h5>\r\n            <div>\r\n                Taking the inner product of the field with the reciprocal basis bivectors yields\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    \\\\begin{aligned}\r\n                    F'_{tx} & = {e^{tx}}' \\\\cdot F = E_x cosh(\\\\varphi_y) \\\\\\\\\r\n                    F'_{xy} & = {e^{xy}}' \\\\cdot F = -E_x sinh(\\\\varphi_y) \\\\\\\\\r\n                    \\\\end{aligned}\r\n                    \\\\label{eq:transform-faraday}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We can see the the TX component of the field gets stronger the faster the observer moves in the Y direction (both positive and negative).\r\n                We also have an XY component. If we look back to how $F$ was defined we can see that this part comes from $I B$,\r\n                specifically the Z component of the magnetic field because {`$e_{xy} = I e_{tz}$`}. So a moving observer will also see a magnetic field\r\n                perpendicular to both their movement direction and the electric field's direction.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    \\\\begin{aligned}\r\n                        E_x' & = E_x cosh(\\\\varphi_y) \\\\\\\\\r\n                        B_z' & = -E_x sinh(\\\\varphi_y)\r\n                    \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We saw that the electromagnetic field is described by the faraday bivector field $F = E + I B$.\r\n                Then we looked at how an observer moving orthogonal to an electric field sees the field.\r\n                We observed that the original electric field gets stronger, but we also saw that the observer measures\r\n                a magnetic field in the direction orthogonal to both the movement direction and the original electric field.\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React, { useEffect, useMemo } from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport { BrowserRouter as Router, Switch, Route, useLocation, Link } from \"react-router-dom\"\r\nimport { TutorialIndex, GATutorial, PGATutorial, Motivation, PGAGeometryTutorial, GADesign1, GADesign2, SRIntro, SRSpacetimeAlgebra, SRSpacetimeRotors, SRLengthContraction, SRGAReview, SRMeasuring, SRElectromagnetism, SRTimeDilation, GADesignInterpolatingPoints } from \"./pages\"\r\nimport * as ga from \"./ga/ga_pp\"\r\nimport * as ga3d from \"./ga/ga_ppp\"\r\nimport * as pga from \"./ga/ga_zpp\"\r\nimport * as viz from \"./ga/viz2d\"\r\n\r\n// Dictionary of path elements to replace with full names\r\n// in the breadcrumbs.\r\nconst breadcrumbPathToName: { [key: string]: string } = {\r\n    \"motivation\": \"Motivation\",\r\n    \"ga-basics\": \"Geometric Algebra Basics\",\r\n    \"pga\": \"Projective Geometric Algebra\",\r\n    \"pga-geometry\": \"PGA Geometry\",\r\n    \"ga-design-1\": \"Designing Geometric Algebras - Shapes\",\r\n    \"ga-design-2\": \"Designing Geometric Algebras - Rotors\",\r\n    \"ga-design-interpolating-points\": \"Designing Geometric Algebras - Interpolating Points\",\r\n    \"sr-intro\": \"Special Relativity with Geometric Algebra - Introduction\",\r\n    \"sr-ga-review\": \"Special Relativity with Geometric Algebra - Geometric Algebra Review\",\r\n    \"sr-spacetime-algebra\": \"Special Relativity with Geometric Algebra - Spacetime Algebra\",\r\n    \"sr-measuring\": \"Special Relativity with Geometric Algebra - Measuring in Spacetime\",\r\n    \"sr-spacetime-rotors\": \"Special Relativity with Geometric Algebra - Spacetime Rotors\",\r\n    \"sr-length-contraction\": \"Special Relativity with Geometric Algebra - Length Contraction\",\r\n    \"sr-electromagnetism\": \"Special Relativity with Geometric Algebra - Electromagnetism\",\r\n}\r\n\r\nexport const pathToBreadcrumbs = (path: string) => {\r\n    const pathNames = [\"Geometric Algebra\"]\r\n    const pathUrls = [\"\"]\r\n\r\n    let cleanedPath = path\r\n    if (cleanedPath[cleanedPath.length - 1] === \"/\") {\r\n        cleanedPath = cleanedPath.substr(0, cleanedPath.length - 1)\r\n    }\r\n\r\n    let pathSplit = cleanedPath.substr(1).split(\"/\")\r\n\r\n    while (pathSplit.length > 0) {\r\n        const pathElement = pathSplit[0]\r\n\r\n        // Add name\r\n        pathNames.push(breadcrumbPathToName[pathElement] ? breadcrumbPathToName[pathElement] : pathElement)\r\n\r\n        // Add url by taking the previous url and concatenating the new path element\r\n        pathUrls.push(`${pathUrls[pathUrls.length - 1]}/${pathSplit[0]}`)\r\n\r\n        // Remove the element we just processed\r\n        pathSplit.splice(0, 1)\r\n    }\r\n\r\n    // Make the first breadcrumb url a slash.\r\n    pathUrls[0] = \"/\"\r\n\r\n    return pathNames.map((name, i) => {\r\n        return { name: name, url: pathUrls[i] }\r\n    })\r\n}\r\n\r\nfunction NotFound() {\r\n    return <h3>Not Found</h3>\r\n}\r\n\r\nfunction TutorialSite() {\r\n    const location = useLocation()\r\n\r\n    const breadcrumbs = useMemo(() => {\r\n        const crumbs = pathToBreadcrumbs(location.pathname)\r\n\r\n        return crumbs\r\n            .map(c => <Link to={c.url}>{c.name}</Link>)\r\n            .reduce((l, r) => <> {l} &gt; {r}  </>)\r\n    }, [location])\r\n\r\n    return (\r\n        <>\r\n            <div className=\"demo-container mdl-grid\">\r\n                <div className=\"mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone\"></div>\r\n                <div\r\n                    className=\"demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col\">\r\n                    <div className=\"demo-crumbs mdl-color-text--grey-500\">\r\n                        {breadcrumbs}\r\n                    </div>\r\n                    <div id=\"section-to-print\">\r\n                        <Switch>\r\n                            <Route path=\"/motivation\">\r\n                                <Motivation />\r\n                            </Route>\r\n                            <Route path=\"/ga-basics\">\r\n                                <GATutorial />\r\n                            </Route>\r\n                            <Route path=\"/pga\">\r\n                                <PGATutorial />\r\n                            </Route>\r\n                            <Route path=\"/pga-geometry\">\r\n                                <PGAGeometryTutorial />\r\n                            </Route>\r\n                            <Route exact path=\"/\">\r\n                                <TutorialIndex />\r\n                            </Route>\r\n                            <Route exact path=\"/ga-design-1\">\r\n                                <GADesign1 />\r\n                            </Route>\r\n                            <Route exact path=\"/ga-design-2\">\r\n                                <GADesign2 />\r\n                            </Route>\r\n                            <Route exact path=\"/ga-design-interpolating-points\">\r\n                                <GADesignInterpolatingPoints />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-intro\">\r\n                                <SRIntro />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-ga-review\">\r\n                                <SRGAReview />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-spacetime-algebra\">\r\n                                <SRSpacetimeAlgebra />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-measuring\">\r\n                                <SRMeasuring />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-spacetime-rotors\">\r\n                                <SRSpacetimeRotors />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-time-dilation\">\r\n                                <SRTimeDilation />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-length-contraction\">\r\n                                <SRLengthContraction />\r\n                            </Route>\r\n                            <Route exact path=\"/sr-electromagnetism\">\r\n                                <SRElectromagnetism />\r\n                            </Route>\r\n                            <Route path=\"*\">\r\n                                <NotFound />\r\n                            </Route>\r\n                        </Switch>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <footer className=\"demo-footer mdl-mini-footer\">\r\n                <div className=\"mdl-mini-footer--left-section\">\r\n                    <ul className=\"mdl-mini-footer--link-list\">\r\n                    </ul>\r\n                </div>\r\n            </footer>\r\n        </>\r\n    )\r\n}\r\n\r\nfunction App() {\r\n    useEffect(() => {\r\n        // Set variables on window so we can use it in interactive code\r\n        const wnd = window as any\r\n        wnd.ga = ga\r\n        wnd.ga3d = ga3d\r\n        wnd.pga = pga\r\n        wnd.viz = viz\r\n        wnd.renderScene = (scene: viz.Scene, renderTarget: HTMLElement) => {\r\n            ReactDOM.render(viz.SceneView({ scene: scene }), renderTarget)\r\n        }\r\n\r\n        // eslint-disable-next-line no-eval\r\n        eval(`\r\n            var ga = wnd.ga;\r\n            var ga3d = wnd.ga3d;\r\n            var pga = wnd.pga;\r\n            var viz = wnd.viz;\r\n            var renderScene = wnd.renderScene;\r\n        `)\r\n    }, [])\r\n\r\n    return (\r\n        <Router>\r\n            <TutorialSite />\r\n        </Router>\r\n    )\r\n}\r\n\r\nexport default App\r\n","export type BladeScalar = { scalar: number }\r\nexport type BladeE0 = { e0: number }\r\nexport type BladeE1 = { e1: number }\r\nexport type BladeE01 = { e01: number }\r\n\r\nexport type Scalar = BladeScalar\r\nexport type Vector = BladeE0 & BladeE1\r\nexport type BiVector = BladeE01\r\nexport type PseudoBiVector = BladeScalar\r\nexport type PseudoVector = BladeE0 & BladeE1\r\nexport type PseudoScalar = BladeE01\r\nexport type Even = BladeScalar & BladeE01\r\nexport type Odd = BladeE0 & BladeE1\r\nexport type MultiVector = BladeScalar & BladeE0 & BladeE1 & BladeE01\r\n\r\nexport type OptionalMultiVector = {\r\n    scalar?: number\r\n    e0?: number\r\n    e1?: number\r\n    e01?: number\r\n}\r\n\r\nexport type AddResultType<A, B> = (\r\n    (A extends BladeScalar ? BladeScalar : {}) &\r\n    (B extends BladeScalar ? BladeScalar : {}) &\r\n    (A extends BladeE0 ? BladeE0 : {}) &\r\n    (B extends BladeE0 ? BladeE0 : {}) &\r\n    (A extends BladeE1 ? BladeE1 : {}) &\r\n    (B extends BladeE1 ? BladeE1 : {}) &\r\n    (A extends BladeE01 ? BladeE01 : {}) &\r\n    (B extends BladeE01 ? BladeE01 : {})\r\n)\r\n\r\nexport const add = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) + (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) + (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) + (b.e1 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) + (b.e01 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport const sub = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) - (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) - (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) - (b.e1 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) - (b.e01 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport type DualResultType<A> = (\r\n    (A extends BladeScalar ? BladeE01 : {}) &\r\n    (A extends BladeE0 ? BladeE1 : {}) &\r\n    (A extends BladeE1 ? BladeE0 : {}) &\r\n    (A extends BladeE01 ? BladeScalar : {})\r\n)\r\n\r\nexport const dual = <A extends OptionalMultiVector>(a: A): DualResultType<A> => {\r\n    const result: any = {\r\n        scalar: a.e01 !== undefined ? 1.0 * a.e01 : undefined,\r\n        e0: a.e1 !== undefined ? 1.0 * a.e1 : undefined,\r\n        e1: a.e0 !== undefined ? -1.0 * a.e0 : undefined,\r\n        e01: a.scalar !== undefined ? 1.0 * a.scalar : undefined,\r\n    }\r\n    return result as DualResultType<A>\r\n}\r\n\r\nexport type GeometricProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE0 ? BladeScalar : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {}) &\r\n        (B extends BladeE01 ? BladeE1 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE0 ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {}) &\r\n        (B extends BladeE01 ? BladeScalar : {})\r\n    ) : {})\r\n\r\nexport const geometricProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): GeometricProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e0 !== undefined && b.e0 !== undefined\r\n    const scalar_2 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_3 = a.e01 !== undefined && b.e01 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e0! * b.e0!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_3) resultScalar += -1.0 * (a.e01! * b.e01!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e01 !== undefined && b.e1 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e0 !== undefined && b.e01 !== undefined\r\n    const e1_2 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_3 = a.e01 !== undefined && b.e0 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e0! * b.e01!)\r\n        if (e1_2) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_3) resultE1 += -1.0 * (a.e01! * b.e0!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e01 !== undefined && b.scalar !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e01: resultE01,\r\n    }\r\n    return result as GeometricProductResultType<A, B>\r\n}\r\n\r\nexport type InnerProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE0 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE1 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE0 ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {}) &\r\n        (B extends BladeE01 ? BladeScalar : {})\r\n    ) : {})\r\n\r\nexport const innerProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): InnerProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e0 !== undefined && b.e0 !== undefined\r\n    const scalar_2 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_3 = a.e01 !== undefined && b.e01 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e0! * b.e0!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_3) resultScalar += -1.0 * (a.e01! * b.e01!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e01 !== undefined && b.e1 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e0 !== undefined && b.e01 !== undefined\r\n    const e1_2 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_3 = a.e01 !== undefined && b.e0 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e0! * b.e01!)\r\n        if (e1_2) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_3) resultE1 += -1.0 * (a.e01! * b.e0!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e01 !== undefined && b.scalar !== undefined\r\n    if (e01_0 || e01_1) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e01: resultE01,\r\n    }\r\n    return result as InnerProductResultType<A, B>\r\n}\r\n\r\nexport type ExteriorProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {})\r\n    ) : {})\r\n\r\nexport const exteriorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): ExteriorProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    if (scalar_0) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    if (e0_0 || e0_1) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e1 !== undefined && b.scalar !== undefined\r\n    if (e1_0 || e1_1) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e01 !== undefined && b.scalar !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e01: resultE01,\r\n    }\r\n    return result as ExteriorProductResultType<A, B>\r\n}\r\n\r\nexport const multiply = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar * b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 * b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 * b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 * b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const div = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar / b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 / b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 / b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 / b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const reversion = <A extends OptionalMultiVector>(a: A): A => {\r\n    const result: any = {\r\n        scalar: a.scalar && a.scalar,\r\n        e0: a.e0 && a.e0,\r\n        e1: a.e1 && a.e1,\r\n        e01: a.e01 && -a.e01,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const repr = <A extends OptionalMultiVector>(a: A, digits: number = 3): string => {\r\n    let result = \"\"\r\n    if (a.scalar !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.scalar.toFixed(digits) + \"\"\r\n        } else {\r\n            result += a.scalar >= 0 ? \" + \" + a.scalar.toFixed(digits) + \"\" : \" - \" + Math.abs(a.scalar).toFixed(digits) + \"\"\r\n        }\r\n    }\r\n    if (a.e0 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e0.toFixed(digits) + \"e0\"\r\n        } else {\r\n            result += a.e0 >= 0 ? \" + \" + a.e0.toFixed(digits) + \"e0\" : \" - \" + Math.abs(a.e0).toFixed(digits) + \"e0\"\r\n        }\r\n    }\r\n    if (a.e1 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e1.toFixed(digits) + \"e1\"\r\n        } else {\r\n            result += a.e1 >= 0 ? \" + \" + a.e1.toFixed(digits) + \"e1\" : \" - \" + Math.abs(a.e1).toFixed(digits) + \"e1\"\r\n        }\r\n    }\r\n    if (a.e01 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e01.toFixed(digits) + \"e01\"\r\n        } else {\r\n            result += a.e01 >= 0 ? \" + \" + a.e01.toFixed(digits) + \"e01\" : \" - \" + Math.abs(a.e01).toFixed(digits) + \"e01\"\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nexport const regressiveProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    dual(exteriorProduct(dual(a), dual(b)))\r\n\r\nexport const sandwichProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    geometricProduct(b, geometricProduct(a, reversion(b)))\r\n\r\nexport const commutatorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    multiply(sub(geometricProduct(a, b), geometricProduct(b, a)), 0.5)\r\n\r\nexport const exponential = <A extends OptionalMultiVector>(a: A) => {\r\n    const gp = geometricProduct(a, a) as any\r\n    const s = gp.scalar || 0\r\n\r\n    // TODO: Check if non-scalar parts are non-zero\r\n\r\n    if (s < 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cos(rootS) }, multiply(a, Math.sin(rootS) / rootS))\r\n    } else if (s > 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cosh(rootS) }, multiply(a, Math.sinh(rootS) / rootS))\r\n    } else {\r\n        return add({ scalar: 1 }, a)\r\n    }\r\n}","export type BladeScalar = { scalar: number }\r\nexport type BladeE0 = { e0: number }\r\nexport type BladeE1 = { e1: number }\r\nexport type BladeE2 = { e2: number }\r\nexport type BladeE01 = { e01: number }\r\nexport type BladeE02 = { e02: number }\r\nexport type BladeE12 = { e12: number }\r\nexport type BladeE012 = { e012: number }\r\n\r\nexport type Scalar = BladeScalar\r\nexport type Vector = BladeE0 & BladeE1 & BladeE2\r\nexport type BiVector = BladeE01 & BladeE02 & BladeE12\r\nexport type TriVector = BladeE012\r\nexport type PseudoTriVector = BladeScalar\r\nexport type PseudoBiVector = BladeE0 & BladeE1 & BladeE2\r\nexport type PseudoVector = BladeE01 & BladeE02 & BladeE12\r\nexport type PseudoScalar = BladeE012\r\nexport type Even = BladeScalar & BladeE01 & BladeE02 & BladeE12\r\nexport type Odd = BladeE0 & BladeE1 & BladeE2 & BladeE012\r\nexport type MultiVector = BladeScalar & BladeE0 & BladeE1 & BladeE2 & BladeE01 & BladeE02 & BladeE12 & BladeE012\r\n\r\nexport type OptionalMultiVector = {\r\n    scalar?: number\r\n    e0?: number\r\n    e1?: number\r\n    e2?: number\r\n    e01?: number\r\n    e02?: number\r\n    e12?: number\r\n    e012?: number\r\n}\r\n\r\nexport type AddResultType<A, B> = (\r\n    (A extends BladeScalar ? BladeScalar : {}) &\r\n    (B extends BladeScalar ? BladeScalar : {}) &\r\n    (A extends BladeE0 ? BladeE0 : {}) &\r\n    (B extends BladeE0 ? BladeE0 : {}) &\r\n    (A extends BladeE1 ? BladeE1 : {}) &\r\n    (B extends BladeE1 ? BladeE1 : {}) &\r\n    (A extends BladeE2 ? BladeE2 : {}) &\r\n    (B extends BladeE2 ? BladeE2 : {}) &\r\n    (A extends BladeE01 ? BladeE01 : {}) &\r\n    (B extends BladeE01 ? BladeE01 : {}) &\r\n    (A extends BladeE02 ? BladeE02 : {}) &\r\n    (B extends BladeE02 ? BladeE02 : {}) &\r\n    (A extends BladeE12 ? BladeE12 : {}) &\r\n    (B extends BladeE12 ? BladeE12 : {}) &\r\n    (A extends BladeE012 ? BladeE012 : {}) &\r\n    (B extends BladeE012 ? BladeE012 : {})\r\n)\r\n\r\nexport const add = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) + (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) + (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) + (b.e1 || 0) : undefined,\r\n        e2: (a.e2 !== undefined || b.e2 !== undefined) ? (a.e2 || 0) + (b.e2 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) + (b.e01 || 0) : undefined,\r\n        e02: (a.e02 !== undefined || b.e02 !== undefined) ? (a.e02 || 0) + (b.e02 || 0) : undefined,\r\n        e12: (a.e12 !== undefined || b.e12 !== undefined) ? (a.e12 || 0) + (b.e12 || 0) : undefined,\r\n        e012: (a.e012 !== undefined || b.e012 !== undefined) ? (a.e012 || 0) + (b.e012 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport const sub = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): AddResultType<A, B> => {\r\n    const result: any = {\r\n        scalar: (a.scalar !== undefined || b.scalar !== undefined) ? (a.scalar || 0) - (b.scalar || 0) : undefined,\r\n        e0: (a.e0 !== undefined || b.e0 !== undefined) ? (a.e0 || 0) - (b.e0 || 0) : undefined,\r\n        e1: (a.e1 !== undefined || b.e1 !== undefined) ? (a.e1 || 0) - (b.e1 || 0) : undefined,\r\n        e2: (a.e2 !== undefined || b.e2 !== undefined) ? (a.e2 || 0) - (b.e2 || 0) : undefined,\r\n        e01: (a.e01 !== undefined || b.e01 !== undefined) ? (a.e01 || 0) - (b.e01 || 0) : undefined,\r\n        e02: (a.e02 !== undefined || b.e02 !== undefined) ? (a.e02 || 0) - (b.e02 || 0) : undefined,\r\n        e12: (a.e12 !== undefined || b.e12 !== undefined) ? (a.e12 || 0) - (b.e12 || 0) : undefined,\r\n        e012: (a.e012 !== undefined || b.e012 !== undefined) ? (a.e012 || 0) - (b.e012 || 0) : undefined,\r\n    }\r\n    return result as AddResultType<A, B>\r\n}\r\n\r\nexport type DualResultType<A> = (\r\n    (A extends BladeScalar ? BladeE012 : {}) &\r\n    (A extends BladeE0 ? BladeE12 : {}) &\r\n    (A extends BladeE1 ? BladeE02 : {}) &\r\n    (A extends BladeE2 ? BladeE01 : {}) &\r\n    (A extends BladeE01 ? BladeE2 : {}) &\r\n    (A extends BladeE02 ? BladeE1 : {}) &\r\n    (A extends BladeE12 ? BladeE0 : {}) &\r\n    (A extends BladeE012 ? BladeScalar : {})\r\n)\r\n\r\nexport const dual = <A extends OptionalMultiVector>(a: A): DualResultType<A> => {\r\n    const result: any = {\r\n        scalar: a.e012 !== undefined ? 1.0 * a.e012 : undefined,\r\n        e0: a.e12 !== undefined ? 1.0 * a.e12 : undefined,\r\n        e1: a.e02 !== undefined ? -1.0 * a.e02 : undefined,\r\n        e2: a.e01 !== undefined ? 1.0 * a.e01 : undefined,\r\n        e01: a.e2 !== undefined ? 1.0 * a.e2 : undefined,\r\n        e02: a.e1 !== undefined ? -1.0 * a.e1 : undefined,\r\n        e12: a.e0 !== undefined ? 1.0 * a.e0 : undefined,\r\n        e012: a.scalar !== undefined ? 1.0 * a.scalar : undefined,\r\n    }\r\n    return result as DualResultType<A>\r\n}\r\n\r\nexport type GeometricProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE0 ? BladeScalar : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE02 : {}) &\r\n        (B extends BladeE01 ? BladeE1 : {}) &\r\n        (B extends BladeE02 ? BladeE2 : {}) &\r\n        (B extends BladeE12 ? BladeE012 : {}) &\r\n        (B extends BladeE012 ? BladeE12 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE2 ? BladeE12 : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {}) &\r\n        (B extends BladeE02 ? BladeE012 : {}) &\r\n        (B extends BladeE12 ? BladeE2 : {}) &\r\n        (B extends BladeE012 ? BladeE02 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE0 ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE12 : {}) &\r\n        (B extends BladeE2 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE012 : {}) &\r\n        (B extends BladeE02 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE1 : {}) &\r\n        (B extends BladeE012 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE0 ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {}) &\r\n        (B extends BladeE2 ? BladeE012 : {}) &\r\n        (B extends BladeE01 ? BladeScalar : {}) &\r\n        (B extends BladeE02 ? BladeE12 : {}) &\r\n        (B extends BladeE12 ? BladeE02 : {}) &\r\n        (B extends BladeE012 ? BladeE2 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE0 ? BladeE2 : {}) &\r\n        (B extends BladeE1 ? BladeE012 : {}) &\r\n        (B extends BladeE2 ? BladeE0 : {}) &\r\n        (B extends BladeE01 ? BladeE12 : {}) &\r\n        (B extends BladeE02 ? BladeScalar : {}) &\r\n        (B extends BladeE12 ? BladeE01 : {}) &\r\n        (B extends BladeE012 ? BladeE1 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE0 ? BladeE012 : {}) &\r\n        (B extends BladeE1 ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeE1 : {}) &\r\n        (B extends BladeE01 ? BladeE02 : {}) &\r\n        (B extends BladeE02 ? BladeE01 : {}) &\r\n        (B extends BladeE12 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {}) &\r\n        (B extends BladeE0 ? BladeE12 : {}) &\r\n        (B extends BladeE1 ? BladeE02 : {}) &\r\n        (B extends BladeE2 ? BladeE01 : {}) &\r\n        (B extends BladeE01 ? BladeE2 : {}) &\r\n        (B extends BladeE02 ? BladeE1 : {}) &\r\n        (B extends BladeE12 ? BladeE0 : {}) &\r\n        (B extends BladeE012 ? BladeScalar : {})\r\n    ) : {})\r\n\r\nexport const geometricProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): GeometricProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e0 !== undefined && b.e0 !== undefined\r\n    const scalar_2 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_3 = a.e2 !== undefined && b.e2 !== undefined\r\n    const scalar_4 = a.e01 !== undefined && b.e01 !== undefined\r\n    const scalar_5 = a.e02 !== undefined && b.e02 !== undefined\r\n    const scalar_6 = a.e12 !== undefined && b.e12 !== undefined\r\n    const scalar_7 = a.e012 !== undefined && b.e012 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3 || scalar_4 || scalar_5 || scalar_6 || scalar_7) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e0! * b.e0!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_3) resultScalar += 1.0 * (a.e2! * b.e2!)\r\n        if (scalar_4) resultScalar += -1.0 * (a.e01! * b.e01!)\r\n        if (scalar_5) resultScalar += -1.0 * (a.e02! * b.e02!)\r\n        if (scalar_6) resultScalar += -1.0 * (a.e12! * b.e12!)\r\n        if (scalar_7) resultScalar += -1.0 * (a.e012! * b.e012!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e2 !== undefined && b.e02 !== undefined\r\n    const e0_4 = a.e01 !== undefined && b.e1 !== undefined\r\n    const e0_5 = a.e02 !== undefined && b.e2 !== undefined\r\n    const e0_6 = a.e12 !== undefined && b.e012 !== undefined\r\n    const e0_7 = a.e012 !== undefined && b.e12 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3 || e0_4 || e0_5 || e0_6 || e0_7) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += -1.0 * (a.e2! * b.e02!)\r\n        if (e0_4) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n        if (e0_5) resultE0 += 1.0 * (a.e02! * b.e2!)\r\n        if (e0_6) resultE0 += -1.0 * (a.e12! * b.e012!)\r\n        if (e0_7) resultE0 += -1.0 * (a.e012! * b.e12!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e0 !== undefined && b.e01 !== undefined\r\n    const e1_2 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_3 = a.e2 !== undefined && b.e12 !== undefined\r\n    const e1_4 = a.e01 !== undefined && b.e0 !== undefined\r\n    const e1_5 = a.e02 !== undefined && b.e012 !== undefined\r\n    const e1_6 = a.e12 !== undefined && b.e2 !== undefined\r\n    const e1_7 = a.e012 !== undefined && b.e02 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3 || e1_4 || e1_5 || e1_6 || e1_7) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e0! * b.e01!)\r\n        if (e1_2) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_3) resultE1 += -1.0 * (a.e2! * b.e12!)\r\n        if (e1_4) resultE1 += -1.0 * (a.e01! * b.e0!)\r\n        if (e1_5) resultE1 += 1.0 * (a.e02! * b.e012!)\r\n        if (e1_6) resultE1 += 1.0 * (a.e12! * b.e2!)\r\n        if (e1_7) resultE1 += 1.0 * (a.e012! * b.e02!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e0 !== undefined && b.e02 !== undefined\r\n    const e2_2 = a.e1 !== undefined && b.e12 !== undefined\r\n    const e2_3 = a.e2 !== undefined && b.scalar !== undefined\r\n    const e2_4 = a.e01 !== undefined && b.e012 !== undefined\r\n    const e2_5 = a.e02 !== undefined && b.e0 !== undefined\r\n    const e2_6 = a.e12 !== undefined && b.e1 !== undefined\r\n    const e2_7 = a.e012 !== undefined && b.e01 !== undefined\r\n    if (e2_0 || e2_1 || e2_2 || e2_3 || e2_4 || e2_5 || e2_6 || e2_7) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e0! * b.e02!)\r\n        if (e2_2) resultE2 += 1.0 * (a.e1! * b.e12!)\r\n        if (e2_3) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n        if (e2_4) resultE2 += -1.0 * (a.e01! * b.e012!)\r\n        if (e2_5) resultE2 += -1.0 * (a.e02! * b.e0!)\r\n        if (e2_6) resultE2 += -1.0 * (a.e12! * b.e1!)\r\n        if (e2_7) resultE2 += -1.0 * (a.e012! * b.e01!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e2 !== undefined && b.e012 !== undefined\r\n    const e01_4 = a.e01 !== undefined && b.scalar !== undefined\r\n    const e01_5 = a.e02 !== undefined && b.e12 !== undefined\r\n    const e01_6 = a.e12 !== undefined && b.e02 !== undefined\r\n    const e01_7 = a.e012 !== undefined && b.e2 !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3 || e01_4 || e01_5 || e01_6 || e01_7) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e2! * b.e012!)\r\n        if (e01_4) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n        if (e01_5) resultE01 += -1.0 * (a.e02! * b.e12!)\r\n        if (e01_6) resultE01 += 1.0 * (a.e12! * b.e02!)\r\n        if (e01_7) resultE01 += 1.0 * (a.e012! * b.e2!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e0 !== undefined && b.e2 !== undefined\r\n    const e02_2 = a.e1 !== undefined && b.e012 !== undefined\r\n    const e02_3 = a.e2 !== undefined && b.e0 !== undefined\r\n    const e02_4 = a.e01 !== undefined && b.e12 !== undefined\r\n    const e02_5 = a.e02 !== undefined && b.scalar !== undefined\r\n    const e02_6 = a.e12 !== undefined && b.e01 !== undefined\r\n    const e02_7 = a.e012 !== undefined && b.e1 !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3 || e02_4 || e02_5 || e02_6 || e02_7) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += 1.0 * (a.e0! * b.e2!)\r\n        if (e02_2) resultE02 += -1.0 * (a.e1! * b.e012!)\r\n        if (e02_3) resultE02 += -1.0 * (a.e2! * b.e0!)\r\n        if (e02_4) resultE02 += 1.0 * (a.e01! * b.e12!)\r\n        if (e02_5) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n        if (e02_6) resultE02 += -1.0 * (a.e12! * b.e01!)\r\n        if (e02_7) resultE02 += -1.0 * (a.e012! * b.e1!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e0 !== undefined && b.e012 !== undefined\r\n    const e12_2 = a.e1 !== undefined && b.e2 !== undefined\r\n    const e12_3 = a.e2 !== undefined && b.e1 !== undefined\r\n    const e12_4 = a.e01 !== undefined && b.e02 !== undefined\r\n    const e12_5 = a.e02 !== undefined && b.e01 !== undefined\r\n    const e12_6 = a.e12 !== undefined && b.scalar !== undefined\r\n    const e12_7 = a.e012 !== undefined && b.e0 !== undefined\r\n    if (e12_0 || e12_1 || e12_2 || e12_3 || e12_4 || e12_5 || e12_6 || e12_7) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e0! * b.e012!)\r\n        if (e12_2) resultE12 += 1.0 * (a.e1! * b.e2!)\r\n        if (e12_3) resultE12 += -1.0 * (a.e2! * b.e1!)\r\n        if (e12_4) resultE12 += -1.0 * (a.e01! * b.e02!)\r\n        if (e12_5) resultE12 += 1.0 * (a.e02! * b.e01!)\r\n        if (e12_6) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n        if (e12_7) resultE12 += 1.0 * (a.e012! * b.e0!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e0 !== undefined && b.e12 !== undefined\r\n    const e012_2 = a.e1 !== undefined && b.e02 !== undefined\r\n    const e012_3 = a.e2 !== undefined && b.e01 !== undefined\r\n    const e012_4 = a.e01 !== undefined && b.e2 !== undefined\r\n    const e012_5 = a.e02 !== undefined && b.e1 !== undefined\r\n    const e012_6 = a.e12 !== undefined && b.e0 !== undefined\r\n    const e012_7 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1 || e012_2 || e012_3 || e012_4 || e012_5 || e012_6 || e012_7) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e0! * b.e12!)\r\n        if (e012_2) resultE012 += -1.0 * (a.e1! * b.e02!)\r\n        if (e012_3) resultE012 += 1.0 * (a.e2! * b.e01!)\r\n        if (e012_4) resultE012 += 1.0 * (a.e01! * b.e2!)\r\n        if (e012_5) resultE012 += -1.0 * (a.e02! * b.e1!)\r\n        if (e012_6) resultE012 += 1.0 * (a.e12! * b.e0!)\r\n        if (e012_7) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as GeometricProductResultType<A, B>\r\n}\r\n\r\nexport type InnerProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE0 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE1 : {}) &\r\n        (B extends BladeE02 ? BladeE2 : {}) &\r\n        (B extends BladeE012 ? BladeE12 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeScalar : {}) &\r\n        (B extends BladeE01 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE2 : {}) &\r\n        (B extends BladeE012 ? BladeE02 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeScalar : {}) &\r\n        (B extends BladeE02 ? BladeE0 : {}) &\r\n        (B extends BladeE12 ? BladeE1 : {}) &\r\n        (B extends BladeE012 ? BladeE01 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE0 ? BladeE1 : {}) &\r\n        (B extends BladeE1 ? BladeE0 : {}) &\r\n        (B extends BladeE01 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE2 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE0 ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeE0 : {}) &\r\n        (B extends BladeE02 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE1 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE1 ? BladeE2 : {}) &\r\n        (B extends BladeE2 ? BladeE1 : {}) &\r\n        (B extends BladeE12 ? BladeScalar : {}) &\r\n        (B extends BladeE012 ? BladeE0 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {}) &\r\n        (B extends BladeE0 ? BladeE12 : {}) &\r\n        (B extends BladeE1 ? BladeE02 : {}) &\r\n        (B extends BladeE2 ? BladeE01 : {}) &\r\n        (B extends BladeE01 ? BladeE2 : {}) &\r\n        (B extends BladeE02 ? BladeE1 : {}) &\r\n        (B extends BladeE12 ? BladeE0 : {}) &\r\n        (B extends BladeE012 ? BladeScalar : {})\r\n    ) : {})\r\n\r\nexport const innerProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): InnerProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    const scalar_1 = a.e0 !== undefined && b.e0 !== undefined\r\n    const scalar_2 = a.e1 !== undefined && b.e1 !== undefined\r\n    const scalar_3 = a.e2 !== undefined && b.e2 !== undefined\r\n    const scalar_4 = a.e01 !== undefined && b.e01 !== undefined\r\n    const scalar_5 = a.e02 !== undefined && b.e02 !== undefined\r\n    const scalar_6 = a.e12 !== undefined && b.e12 !== undefined\r\n    const scalar_7 = a.e012 !== undefined && b.e012 !== undefined\r\n    if (scalar_0 || scalar_1 || scalar_2 || scalar_3 || scalar_4 || scalar_5 || scalar_6 || scalar_7) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n        if (scalar_1) resultScalar += 1.0 * (a.e0! * b.e0!)\r\n        if (scalar_2) resultScalar += 1.0 * (a.e1! * b.e1!)\r\n        if (scalar_3) resultScalar += 1.0 * (a.e2! * b.e2!)\r\n        if (scalar_4) resultScalar += -1.0 * (a.e01! * b.e01!)\r\n        if (scalar_5) resultScalar += -1.0 * (a.e02! * b.e02!)\r\n        if (scalar_6) resultScalar += -1.0 * (a.e12! * b.e12!)\r\n        if (scalar_7) resultScalar += -1.0 * (a.e012! * b.e012!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    const e0_2 = a.e1 !== undefined && b.e01 !== undefined\r\n    const e0_3 = a.e2 !== undefined && b.e02 !== undefined\r\n    const e0_4 = a.e01 !== undefined && b.e1 !== undefined\r\n    const e0_5 = a.e02 !== undefined && b.e2 !== undefined\r\n    const e0_6 = a.e12 !== undefined && b.e012 !== undefined\r\n    const e0_7 = a.e012 !== undefined && b.e12 !== undefined\r\n    if (e0_0 || e0_1 || e0_2 || e0_3 || e0_4 || e0_5 || e0_6 || e0_7) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n        if (e0_2) resultE0 += -1.0 * (a.e1! * b.e01!)\r\n        if (e0_3) resultE0 += -1.0 * (a.e2! * b.e02!)\r\n        if (e0_4) resultE0 += 1.0 * (a.e01! * b.e1!)\r\n        if (e0_5) resultE0 += 1.0 * (a.e02! * b.e2!)\r\n        if (e0_6) resultE0 += -1.0 * (a.e12! * b.e012!)\r\n        if (e0_7) resultE0 += -1.0 * (a.e012! * b.e12!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e0 !== undefined && b.e01 !== undefined\r\n    const e1_2 = a.e1 !== undefined && b.scalar !== undefined\r\n    const e1_3 = a.e2 !== undefined && b.e12 !== undefined\r\n    const e1_4 = a.e01 !== undefined && b.e0 !== undefined\r\n    const e1_5 = a.e02 !== undefined && b.e012 !== undefined\r\n    const e1_6 = a.e12 !== undefined && b.e2 !== undefined\r\n    const e1_7 = a.e012 !== undefined && b.e02 !== undefined\r\n    if (e1_0 || e1_1 || e1_2 || e1_3 || e1_4 || e1_5 || e1_6 || e1_7) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e0! * b.e01!)\r\n        if (e1_2) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n        if (e1_3) resultE1 += -1.0 * (a.e2! * b.e12!)\r\n        if (e1_4) resultE1 += -1.0 * (a.e01! * b.e0!)\r\n        if (e1_5) resultE1 += 1.0 * (a.e02! * b.e012!)\r\n        if (e1_6) resultE1 += 1.0 * (a.e12! * b.e2!)\r\n        if (e1_7) resultE1 += 1.0 * (a.e012! * b.e02!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e0 !== undefined && b.e02 !== undefined\r\n    const e2_2 = a.e1 !== undefined && b.e12 !== undefined\r\n    const e2_3 = a.e2 !== undefined && b.scalar !== undefined\r\n    const e2_4 = a.e01 !== undefined && b.e012 !== undefined\r\n    const e2_5 = a.e02 !== undefined && b.e0 !== undefined\r\n    const e2_6 = a.e12 !== undefined && b.e1 !== undefined\r\n    const e2_7 = a.e012 !== undefined && b.e01 !== undefined\r\n    if (e2_0 || e2_1 || e2_2 || e2_3 || e2_4 || e2_5 || e2_6 || e2_7) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e0! * b.e02!)\r\n        if (e2_2) resultE2 += 1.0 * (a.e1! * b.e12!)\r\n        if (e2_3) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n        if (e2_4) resultE2 += -1.0 * (a.e01! * b.e012!)\r\n        if (e2_5) resultE2 += -1.0 * (a.e02! * b.e0!)\r\n        if (e2_6) resultE2 += -1.0 * (a.e12! * b.e1!)\r\n        if (e2_7) resultE2 += -1.0 * (a.e012! * b.e01!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e2 !== undefined && b.e012 !== undefined\r\n    const e01_2 = a.e01 !== undefined && b.scalar !== undefined\r\n    const e01_3 = a.e012 !== undefined && b.e2 !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e2! * b.e012!)\r\n        if (e01_2) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e012! * b.e2!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e1 !== undefined && b.e012 !== undefined\r\n    const e02_2 = a.e02 !== undefined && b.scalar !== undefined\r\n    const e02_3 = a.e012 !== undefined && b.e1 !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += -1.0 * (a.e1! * b.e012!)\r\n        if (e02_2) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n        if (e02_3) resultE02 += -1.0 * (a.e012! * b.e1!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e0 !== undefined && b.e012 !== undefined\r\n    const e12_2 = a.e12 !== undefined && b.scalar !== undefined\r\n    const e12_3 = a.e012 !== undefined && b.e0 !== undefined\r\n    if (e12_0 || e12_1 || e12_2 || e12_3) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e0! * b.e012!)\r\n        if (e12_2) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n        if (e12_3) resultE12 += 1.0 * (a.e012! * b.e0!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as InnerProductResultType<A, B>\r\n}\r\n\r\nexport type ExteriorProductResultType<A, B> =\r\n    (A extends BladeScalar ? (\r\n        (B extends BladeScalar ? BladeScalar : {}) &\r\n        (B extends BladeE0 ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE1 : {}) &\r\n        (B extends BladeE2 ? BladeE2 : {}) &\r\n        (B extends BladeE01 ? BladeE01 : {}) &\r\n        (B extends BladeE02 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE12 : {}) &\r\n        (B extends BladeE012 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE0 ? (\r\n        (B extends BladeScalar ? BladeE0 : {}) &\r\n        (B extends BladeE1 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE02 : {}) &\r\n        (B extends BladeE12 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE1 ? (\r\n        (B extends BladeScalar ? BladeE1 : {}) &\r\n        (B extends BladeE0 ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE12 : {}) &\r\n        (B extends BladeE02 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE2 ? (\r\n        (B extends BladeScalar ? BladeE2 : {}) &\r\n        (B extends BladeE0 ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE12 : {}) &\r\n        (B extends BladeE01 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE01 ? (\r\n        (B extends BladeScalar ? BladeE01 : {}) &\r\n        (B extends BladeE2 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE02 ? (\r\n        (B extends BladeScalar ? BladeE02 : {}) &\r\n        (B extends BladeE1 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE12 ? (\r\n        (B extends BladeScalar ? BladeE12 : {}) &\r\n        (B extends BladeE0 ? BladeE012 : {})\r\n    ) : {}) &\r\n    (A extends BladeE012 ? (\r\n        (B extends BladeScalar ? BladeE012 : {})\r\n    ) : {})\r\n\r\nexport const exteriorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B): ExteriorProductResultType<A, B> => {\r\n    let resultScalar = undefined\r\n    const scalar_0 = a.scalar !== undefined && b.scalar !== undefined\r\n    if (scalar_0) {\r\n        resultScalar = 0\r\n        if (scalar_0) resultScalar += 1.0 * (a.scalar! * b.scalar!)\r\n    }\r\n    let resultE0 = undefined\r\n    const e0_0 = a.scalar !== undefined && b.e0 !== undefined\r\n    const e0_1 = a.e0 !== undefined && b.scalar !== undefined\r\n    if (e0_0 || e0_1) {\r\n        resultE0 = 0\r\n        if (e0_0) resultE0 += 1.0 * (a.scalar! * b.e0!)\r\n        if (e0_1) resultE0 += 1.0 * (a.e0! * b.scalar!)\r\n    }\r\n    let resultE1 = undefined\r\n    const e1_0 = a.scalar !== undefined && b.e1 !== undefined\r\n    const e1_1 = a.e1 !== undefined && b.scalar !== undefined\r\n    if (e1_0 || e1_1) {\r\n        resultE1 = 0\r\n        if (e1_0) resultE1 += 1.0 * (a.scalar! * b.e1!)\r\n        if (e1_1) resultE1 += 1.0 * (a.e1! * b.scalar!)\r\n    }\r\n    let resultE2 = undefined\r\n    const e2_0 = a.scalar !== undefined && b.e2 !== undefined\r\n    const e2_1 = a.e2 !== undefined && b.scalar !== undefined\r\n    if (e2_0 || e2_1) {\r\n        resultE2 = 0\r\n        if (e2_0) resultE2 += 1.0 * (a.scalar! * b.e2!)\r\n        if (e2_1) resultE2 += 1.0 * (a.e2! * b.scalar!)\r\n    }\r\n    let resultE01 = undefined\r\n    const e01_0 = a.scalar !== undefined && b.e01 !== undefined\r\n    const e01_1 = a.e0 !== undefined && b.e1 !== undefined\r\n    const e01_2 = a.e1 !== undefined && b.e0 !== undefined\r\n    const e01_3 = a.e01 !== undefined && b.scalar !== undefined\r\n    if (e01_0 || e01_1 || e01_2 || e01_3) {\r\n        resultE01 = 0\r\n        if (e01_0) resultE01 += 1.0 * (a.scalar! * b.e01!)\r\n        if (e01_1) resultE01 += 1.0 * (a.e0! * b.e1!)\r\n        if (e01_2) resultE01 += -1.0 * (a.e1! * b.e0!)\r\n        if (e01_3) resultE01 += 1.0 * (a.e01! * b.scalar!)\r\n    }\r\n    let resultE02 = undefined\r\n    const e02_0 = a.scalar !== undefined && b.e02 !== undefined\r\n    const e02_1 = a.e0 !== undefined && b.e2 !== undefined\r\n    const e02_2 = a.e2 !== undefined && b.e0 !== undefined\r\n    const e02_3 = a.e02 !== undefined && b.scalar !== undefined\r\n    if (e02_0 || e02_1 || e02_2 || e02_3) {\r\n        resultE02 = 0\r\n        if (e02_0) resultE02 += 1.0 * (a.scalar! * b.e02!)\r\n        if (e02_1) resultE02 += 1.0 * (a.e0! * b.e2!)\r\n        if (e02_2) resultE02 += -1.0 * (a.e2! * b.e0!)\r\n        if (e02_3) resultE02 += 1.0 * (a.e02! * b.scalar!)\r\n    }\r\n    let resultE12 = undefined\r\n    const e12_0 = a.scalar !== undefined && b.e12 !== undefined\r\n    const e12_1 = a.e1 !== undefined && b.e2 !== undefined\r\n    const e12_2 = a.e2 !== undefined && b.e1 !== undefined\r\n    const e12_3 = a.e12 !== undefined && b.scalar !== undefined\r\n    if (e12_0 || e12_1 || e12_2 || e12_3) {\r\n        resultE12 = 0\r\n        if (e12_0) resultE12 += 1.0 * (a.scalar! * b.e12!)\r\n        if (e12_1) resultE12 += 1.0 * (a.e1! * b.e2!)\r\n        if (e12_2) resultE12 += -1.0 * (a.e2! * b.e1!)\r\n        if (e12_3) resultE12 += 1.0 * (a.e12! * b.scalar!)\r\n    }\r\n    let resultE012 = undefined\r\n    const e012_0 = a.scalar !== undefined && b.e012 !== undefined\r\n    const e012_1 = a.e0 !== undefined && b.e12 !== undefined\r\n    const e012_2 = a.e1 !== undefined && b.e02 !== undefined\r\n    const e012_3 = a.e2 !== undefined && b.e01 !== undefined\r\n    const e012_4 = a.e01 !== undefined && b.e2 !== undefined\r\n    const e012_5 = a.e02 !== undefined && b.e1 !== undefined\r\n    const e012_6 = a.e12 !== undefined && b.e0 !== undefined\r\n    const e012_7 = a.e012 !== undefined && b.scalar !== undefined\r\n    if (e012_0 || e012_1 || e012_2 || e012_3 || e012_4 || e012_5 || e012_6 || e012_7) {\r\n        resultE012 = 0\r\n        if (e012_0) resultE012 += 1.0 * (a.scalar! * b.e012!)\r\n        if (e012_1) resultE012 += 1.0 * (a.e0! * b.e12!)\r\n        if (e012_2) resultE012 += -1.0 * (a.e1! * b.e02!)\r\n        if (e012_3) resultE012 += 1.0 * (a.e2! * b.e01!)\r\n        if (e012_4) resultE012 += 1.0 * (a.e01! * b.e2!)\r\n        if (e012_5) resultE012 += -1.0 * (a.e02! * b.e1!)\r\n        if (e012_6) resultE012 += 1.0 * (a.e12! * b.e0!)\r\n        if (e012_7) resultE012 += 1.0 * (a.e012! * b.scalar!)\r\n    }\r\n    const result: any = {\r\n        scalar: resultScalar,\r\n        e0: resultE0,\r\n        e1: resultE1,\r\n        e2: resultE2,\r\n        e01: resultE01,\r\n        e02: resultE02,\r\n        e12: resultE12,\r\n        e012: resultE012,\r\n    }\r\n    return result as ExteriorProductResultType<A, B>\r\n}\r\n\r\nexport const multiply = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar * b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 * b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 * b : undefined,\r\n        e2: a.e2 !== undefined ? a.e2 * b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 * b : undefined,\r\n        e02: a.e02 !== undefined ? a.e02 * b : undefined,\r\n        e12: a.e12 !== undefined ? a.e12 * b : undefined,\r\n        e012: a.e012 !== undefined ? a.e012 * b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const div = <A extends OptionalMultiVector>(a: A, b: number): A => {\r\n    const result: any = {\r\n        scalar: a.scalar !== undefined ? a.scalar / b : undefined,\r\n        e0: a.e0 !== undefined ? a.e0 / b : undefined,\r\n        e1: a.e1 !== undefined ? a.e1 / b : undefined,\r\n        e2: a.e2 !== undefined ? a.e2 / b : undefined,\r\n        e01: a.e01 !== undefined ? a.e01 / b : undefined,\r\n        e02: a.e02 !== undefined ? a.e02 / b : undefined,\r\n        e12: a.e12 !== undefined ? a.e12 / b : undefined,\r\n        e012: a.e012 !== undefined ? a.e012 / b : undefined,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const reversion = <A extends OptionalMultiVector>(a: A): A => {\r\n    const result: any = {\r\n        scalar: a.scalar && a.scalar,\r\n        e0: a.e0 && a.e0,\r\n        e1: a.e1 && a.e1,\r\n        e2: a.e2 && a.e2,\r\n        e01: a.e01 && -a.e01,\r\n        e02: a.e02 && -a.e02,\r\n        e12: a.e12 && -a.e12,\r\n        e012: a.e012 && -a.e012,\r\n    }\r\n    return result as A\r\n}\r\n\r\nexport const repr = <A extends OptionalMultiVector>(a: A, digits: number = 3): string => {\r\n    let result = \"\"\r\n    if (a.scalar !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.scalar.toFixed(digits) + \"\"\r\n        } else {\r\n            result += a.scalar >= 0 ? \" + \" + a.scalar.toFixed(digits) + \"\" : \" - \" + Math.abs(a.scalar).toFixed(digits) + \"\"\r\n        }\r\n    }\r\n    if (a.e0 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e0.toFixed(digits) + \"e0\"\r\n        } else {\r\n            result += a.e0 >= 0 ? \" + \" + a.e0.toFixed(digits) + \"e0\" : \" - \" + Math.abs(a.e0).toFixed(digits) + \"e0\"\r\n        }\r\n    }\r\n    if (a.e1 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e1.toFixed(digits) + \"e1\"\r\n        } else {\r\n            result += a.e1 >= 0 ? \" + \" + a.e1.toFixed(digits) + \"e1\" : \" - \" + Math.abs(a.e1).toFixed(digits) + \"e1\"\r\n        }\r\n    }\r\n    if (a.e2 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e2.toFixed(digits) + \"e2\"\r\n        } else {\r\n            result += a.e2 >= 0 ? \" + \" + a.e2.toFixed(digits) + \"e2\" : \" - \" + Math.abs(a.e2).toFixed(digits) + \"e2\"\r\n        }\r\n    }\r\n    if (a.e01 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e01.toFixed(digits) + \"e01\"\r\n        } else {\r\n            result += a.e01 >= 0 ? \" + \" + a.e01.toFixed(digits) + \"e01\" : \" - \" + Math.abs(a.e01).toFixed(digits) + \"e01\"\r\n        }\r\n    }\r\n    if (a.e02 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e02.toFixed(digits) + \"e02\"\r\n        } else {\r\n            result += a.e02 >= 0 ? \" + \" + a.e02.toFixed(digits) + \"e02\" : \" - \" + Math.abs(a.e02).toFixed(digits) + \"e02\"\r\n        }\r\n    }\r\n    if (a.e12 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e12.toFixed(digits) + \"e12\"\r\n        } else {\r\n            result += a.e12 >= 0 ? \" + \" + a.e12.toFixed(digits) + \"e12\" : \" - \" + Math.abs(a.e12).toFixed(digits) + \"e12\"\r\n        }\r\n    }\r\n    if (a.e012 !== undefined) {\r\n        if (result === \"\") {\r\n            result += a.e012.toFixed(digits) + \"e012\"\r\n        } else {\r\n            result += a.e012 >= 0 ? \" + \" + a.e012.toFixed(digits) + \"e012\" : \" - \" + Math.abs(a.e012).toFixed(digits) + \"e012\"\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nexport const regressiveProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    dual(exteriorProduct(dual(a), dual(b)))\r\n\r\nexport const sandwichProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    geometricProduct(b, geometricProduct(a, reversion(b)))\r\n\r\nexport const commutatorProduct = <A extends OptionalMultiVector, B extends OptionalMultiVector>(a: A, b: B) =>\r\n    multiply(sub(geometricProduct(a, b), geometricProduct(b, a)), 0.5)\r\n\r\nexport const exponential = <A extends OptionalMultiVector>(a: A) => {\r\n    const gp = geometricProduct(a, a) as any\r\n    const s = gp.scalar || 0\r\n\r\n    // TODO: Check if non-scalar parts are non-zero\r\n\r\n    if (s < 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cos(rootS) }, multiply(a, Math.sin(rootS) / rootS))\r\n    } else if (s > 0) {\r\n        const rootS = Math.sign(s) * Math.sqrt(Math.abs(s))\r\n        return add({ scalar: Math.cosh(rootS) }, multiply(a, Math.sinh(rootS) / rootS))\r\n    } else {\r\n        return add({ scalar: 1 }, a)\r\n    }\r\n}","/* eslint-disable no-eval */\r\nimport React, { useState, useCallback, useRef, useMemo } from \"react\"\r\nimport styles from \"./InteractiveCode.module.css\"\r\nimport AceEditor from \"react-ace\"\r\nimport \"brace/mode/javascript\"\r\nimport \"brace/theme/monokai\"\r\nimport { SceneView } from \"../ga/viz2d\"\r\n\r\n\r\nexport type InteractiveCodeProps = {\r\n    style?: React.CSSProperties\r\n\r\n    sourceCode: string\r\n    editorStyle?: React.CSSProperties\r\n\r\n    hideOutput?: boolean\r\n    outputStyle?: React.CSSProperties\r\n\r\n    withVisualizer?: boolean\r\n    visualizerStyle?: React.CSSProperties\r\n}\r\n\r\nconst formatObject = (obj: any) => {\r\n    return typeof obj === \"string\" ?\r\n        obj : (\r\n            typeof obj === \"number\" ?\r\n                obj.toString() :\r\n                JSON.stringify(obj, null, 4)\r\n        )\r\n}\r\n\r\nexport function InteractiveCode(props: InteractiveCodeProps) {\r\n    const {\r\n        sourceCode, editorStyle, hideOutput, withVisualizer, visualizerStyle,\r\n        outputStyle, style\r\n    } = props\r\n\r\n    // Store the edited code\r\n    const [code, setCode] = useState(sourceCode)\r\n\r\n    // Store the result of runs\r\n    const [runResult, setRunResult] = useState(\"Press run\")\r\n\r\n    // Run the code.\r\n    const run = useCallback(() => {\r\n        const oldLog = console.log\r\n\r\n        const newRunResults: string[] = []\r\n\r\n        console.log = (message?: any, ...optionalParams: any[]) => {\r\n            newRunResults.push(\r\n                (message !== undefined ? formatObject(message) + \" \" : \"\") +\r\n                optionalParams.map(formatObject).join(\" \")\r\n            )\r\n            oldLog(message, ...optionalParams)\r\n        }\r\n\r\n        let codeToRun = code;\r\n        const renderTarget = withVisualizer && visualizerRef.current\r\n\r\n        // Add helpers when using visualizer\r\n        if (renderTarget) {\r\n            codeToRun = `\r\n                var points = [];\r\n                var lines = [];\r\n                var infos = [];\r\n                var renderPointPGA = (p, color) => points.push({point: p, radius: 4, fill: color});\r\n                var renderLinePGA = (l, color) => lines.push({line: l, width: 2, stroke: color});\r\n                var renderPointGA = (p, color) => renderPointPGA({e02: -p.e0, e01: p.e1, e12: 1}, color);\r\n                var renderInfo = (info, color) => infos.push({text: info, fontSize: 4, color: color});\r\n                var renderBoxPGA = (m, color, h) => {\r\n                    h = h || 3\r\n                    var corners = [\r\n                        {\r\n                            e01: -h,\r\n                            e02: -h,\r\n                            e12: 1\r\n                        },\r\n                        {\r\n                            e01: h,\r\n                            e02: -h,\r\n                            e12: 1\r\n                        },\r\n                        {\r\n                            e01: h,\r\n                            e02: h,\r\n                            e12: 1\r\n                        },\r\n                        {\r\n                            e01: -h,\r\n                            e02: h,\r\n                            e12: 1\r\n                        }\r\n                    ];\r\n\r\n                    for (var cornerIndex = 0; cornerIndex < corners.length; cornerIndex++) {\r\n                        points.push({point: pga.sandwichProduct(corners[cornerIndex], m), radius: 2, fill: color});\r\n                    }\r\n                };\r\n            ` + codeToRun + `\r\n                renderScene({ points: points, lines: lines, infos: infos }, document.getElementById(\"${renderTarget.id}\"));\r\n            `\r\n        }\r\n\r\n        // Declare log() so we can write shorter code\r\n        codeToRun = \"var log = console.log;\" + codeToRun\r\n\r\n        try {\r\n            eval(codeToRun)\r\n            setRunResult(newRunResults.join(\"\\n\"))\r\n        } catch (e: any) {\r\n            setRunResult(e.toString())\r\n        }\r\n\r\n        console.log = oldLog\r\n    }, [code, withVisualizer])\r\n\r\n    // Unique id so we can refer to the div element that contains the \r\n    // svg render target later if we use a visualizer.\r\n    const uniqueId = useMemo(() => {\r\n        return (Math.random().toString(36) + \"00000000000000000\").slice(2, 18)\r\n    }, [])\r\n\r\n    const visualizerRef = useRef<HTMLDivElement>(null)\r\n\r\n    return (\r\n        <div className={styles[\"interactive-code\"]} style={style}>\r\n            <div style={{ position: \"relative\", width: \"100%\" }}>\r\n                <button style={{ border: 0, background: \"#505050\", color: \"#FFFFFF\", position: \"absolute\", right: 10, top: 10, fontSize: 24, zIndex: 10 }} onClick={run}>Run</button>\r\n            </div>\r\n            <div style={{ display: \"flex\", flexDirection: \"column\", alignContent: \"stretch\" }}>\r\n                <div style={{ display: \"flex\", flexDirection: \"row\", alignContent: \"stretch\", flexWrap: \"wrap\" }}>\r\n                    <AceEditor className={withVisualizer ? styles[\"interactive-code-editor-with-viz\"] : styles[\"interactive-code-editor-without-viz\"]}\r\n                        style={{ ...{ width: undefined, height: undefined }, ...editorStyle }}\r\n                        mode=\"javascript\" theme=\"monokai\" value={code} onChange={e => setCode(e)}\r\n                        showPrintMargin={false}\r\n                    />\r\n\r\n                    {withVisualizer &&\r\n                        <div id={`#${uniqueId}`} ref={visualizerRef} className={styles[\"interactive-code-viz\"]} style={visualizerStyle}>\r\n                            <SceneView scene={{}} />\r\n                        </div>\r\n                    }\r\n                </div>\r\n\r\n                {!hideOutput &&\r\n                    <AceEditor className={styles[\"interactive-code-output\"]} style={{ ...{ width: undefined, height: undefined }, ...outputStyle }}\r\n                        mode=\"javascript\" theme=\"monokai\" value={runResult} readOnly={true}\r\n                        showPrintMargin={false}\r\n                    />\r\n                }\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\"\r\nimport { hydrate, render } from \"react-dom\"\r\nimport \"./index.css\"\r\nimport App from \"./App\"\r\nimport reportWebVitals from \"./reportWebVitals\"\r\n\r\nfunction getApp() {\r\n    return (\r\n        <React.StrictMode>\r\n            <App />\r\n        </React.StrictMode>\r\n    )\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\")\r\nif (rootElement) {\r\n    if (rootElement.hasChildNodes()) {\r\n        hydrate(getApp(), rootElement)\r\n    } else {\r\n        render(getApp(), rootElement)\r\n    }\r\n}\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\n\r\nexport function TutorialIndex() {\r\n    return (\r\n        <div>\r\n            <h3>Index</h3>\r\n            <div>\r\n\r\n            </div>\r\n            <h4>Geometric Algebra and Projective Geometric Algebra Introduction</h4>\r\n            <div>\r\n                Introduction to the basics of Geometric Algebra (GA) and Projective Geometric Algebra (PGA).\r\n                This tutorial teaches GA in an interactive way with runnable code and visualizations.\r\n                It is not meant to be an entirely bottom-up way where we try to derive every single result.\r\n                Instead the focus is on trying to create an understanding for GA and gradually introduce new things while\r\n                directly applying the learnt concepts.\r\n            </div>\r\n            <ol>\r\n                <li><Link to=\"/motivation\">Motivation</Link></li>\r\n                <li><Link to=\"/ga-basics\">Geometric Algebra Basics</Link></li>\r\n                <li><Link to=\"/pga\">Projective Geometric Algebra</Link></li>\r\n            </ol>\r\n            <h4>Design of Geometric Algebras</h4>\r\n            <div>\r\n                Shows how we can create Geometric Algebras which can represent any shape and how we can get useful rotors in them.\r\n            </div>\r\n            <ol>\r\n                <li><Link to=\"/ga-design-1\">Design of Geometric Algebras - Shapes</Link></li>\r\n                <li><Link to=\"/ga-design-2\">Design of Geometric Algebras - Rotors</Link> <b style={{ color: \"red\" }}>(WIP, flawed)</b></li>\r\n                <li><Link to=\"/ga-design-interpolating-points\">Design of Geometric Algebras - Interpolating Points</Link></li>\r\n            </ol>\r\n            <h4>Special Relativity with Geometric Algebra</h4>\r\n            <div>\r\n                Introduction to Special Relativity using Geometric Algebra. Work in progress. Likely contains errors.\r\n            </div>\r\n            <div>\r\n                <h5>Known issues / todo list</h5>\r\n                <ul>\r\n                    <li>Add more applications</li>\r\n                    <li>Update all graphics and add more (they are all just sketches currently)</li>\r\n                </ul>\r\n            </div>\r\n            <ol>\r\n                <li><Link to=\"/sr-intro\">Special Relativity with Geometric Algebra - Introduction</Link></li>\r\n                <li><Link to=\"/sr-ga-review\">Special Relativity with Geometric Algebra - Geometric Algebra Review</Link></li>\r\n                <li><Link to=\"/sr-spacetime-algebra\">Special Relativity with Geometric Algebra - Spacetime Algebra</Link></li>\r\n                <li><Link to=\"/sr-spacetime-rotors\">Special Relativity with Geometric Algebra - Spacetime Rotors</Link></li>\r\n                <li><Link to=\"/sr-measuring\">Special Relativity with Geometric Algebra - Measuring in Spacetime</Link></li>\r\n                <li><Link to=\"/sr-time-dilation\">Special Relativity with Geometric Algebra - Time Dilation</Link></li>\r\n                <li><Link to=\"/sr-length-contraction\">Special Relativity with Geometric Algebra - Length Contraction</Link></li>\r\n                <li><Link to=\"/sr-electromagnetism\">Special Relativity with Geometric Algebra - Electromagnetism</Link></li>\r\n            </ol>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\n\r\n\r\nexport function Motivation() {\r\n    return (\r\n        <div>\r\n            <h3>Motivation</h3>\r\n\r\n            <h5>CoffeeShop Examples</h5>\r\n            <div>\r\n                The CoffeeShop is a website containing many examples making use of Geometric Algebra.\r\n                Below I listed some interesting ones. After completing this tutorial we will be able\r\n                to reproduce them.\r\n            </div>\r\n            <ul>\r\n                <li><a href=\"https://enkimute.github.io/ganja.js/examples/coffeeshop.html#pga3d_skinning\">Skinning (smooth blending)</a></li>\r\n                <li><a href=\"https://enkimute.github.io/ganja.js/examples/coffeeshop.html#pga3d_physics_symmetric_top\">Rigidbody physics with unified rotation and translation</a></li>\r\n                <li><a href=\"https://enkimute.github.io/ganja.js/examples/coffeeshop.html#pga2d_inverse_kinematics\">Inverse kinematics</a></li>\r\n                <li><a href=\"https://enkimute.github.io/ganja.js/examples/coffeeshop.html#pga2d_differentiation\">Automatic differentiation</a></li>\r\n                <li><a href=\"https://enkimute.github.io/ganja.js/examples/coffeeshop.html#ga3d_rotor_estimation\">Rotor estimation between two point clouds</a></li>\r\n            </ul>\r\n\r\n            <h4><Link to=\"/ga-basics\">Next: Geometric Algebra Basics</Link></h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { InteractiveCode } from \"./InteractiveCode\"\r\nimport * as cnt from \"./CodeGATutorial\"\r\nimport { useMathJax } from \"../util\"\r\n\r\nexport function GATutorial() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Geometric Algebra Basics</h3>\r\n            <div>\r\n                Usually introductions to GA begin by defining various rules and going over derivations\r\n                before doing anything useful with them. I will also define some rules but try to\r\n                get to the interesting stuff more quickly.\r\n            </div>\r\n\r\n            <h4>Vectors</h4>\r\n            <div>\r\n                Like for the standard 2D vector algebra in GA we have two basis vectors $e_x, e_y$\r\n                using which arbitrary vectors $v = x e_x + y e_y$ can be formed. Below is some runnable and editable\r\n                code that forms such vectors and then displays them as points. The basis vectors\r\n                $e_x, e_y$ are labeled <code>e0</code> and <code>e1</code> in the code. We specify the non-zero\r\n                coefficients for each basis vector when creating a new vector.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.codeRenderPoint}\r\n                hideOutput={true} withVisualizer={true}\r\n            />\r\n\r\n            <h4>Geometric Product</h4>\r\n            <div>\r\n                The product which defines Geometric Algebra and is its most important aspect is called the\r\n                Geometric Product. There are two useful rules for using the geometric product which will now\r\n                be introduced.\r\n            </div>\r\n            <h5>Rule 1: Basis vectors square to +1</h5>\r\n            <div>\r\n                 Multiplying two same basis vectors together with the geometric product\r\n                will result in $+1$ (for now...) if they are the same.\r\n\r\n                {`\\\\begin{equation}\r\n                e_x e_x = 1, e_y e_y = 1\r\n                \\\\end{equation}`}\r\n\r\n                This is similar to how the dot product in standard vector algebra works.\r\n                Let's verify these results with the code again, this time just logging some text instead of visualizing.\r\n            </div>\r\n            <InteractiveCode sourceCode={cnt.codeSquareBasisVectors} />\r\n\r\n            <h5>Rule 2: Different basis vectors anti-commute</h5>\r\n            <div>\r\n                What is new is that we can also multiply two different basis vectors and the result will not be zero,\r\n                but instead can't be simplified further.\r\n\r\n                {`\\\\begin{equation}\r\n                e_x e_y = e_{xy}\r\n                \\\\end{equation}`}\r\n\r\n                {`$e_{xy}$`} here is just shorthand for the two basis vectors multiplied together.\r\n                Such elements made up of two basis vectors are called bivectors.\r\n            </div>\r\n            <div>\r\n                Importantly the order of the product matters. A rule is that when you swap the factors\r\n                of a product of basis vectors you pick up a minus sign. We say that the basis vectors anti-commute.\r\n\r\n                {`\\\\begin{equation}\r\n                e_{xy} = e_x e_y = -e_y e_x = -e_{yx}\r\n                \\\\end{equation}`}\r\n            </div>\r\n            <InteractiveCode sourceCode={cnt.codeExteriorProduct} />\r\n\r\n            <h5>Practice</h5>\r\n            <div>\r\n                Let's now use these two basic rules we just learnt and see what some results are when we use them:\r\n\r\n                {`\\\\begin{aligned}\r\n                e_x e_y e_x & = & \\\\text{(Rewrite as shorthand)} \\\\\\\\\r\n                e_{xyx} & = & \\\\text{(Swap neighbours on the right, pick up minus sign)} \\\\\\\\\r\n                -e_{xxy} & = & \\\\text{(Multiplying same basis vectors results in 1, e_xx = e_x e_x = 1)} \\\\\\\\\r\n                -e_y &\r\n                \\\\end{aligned}`}\r\n\r\n                We can verify these results with the code:\r\n            </div>\r\n            \r\n            <InteractiveCode sourceCode={cnt.codeAntiCommute} />\r\n\r\n            <h5>Terminology</h5>\r\n            <div>\r\n                <div>Here's a list of some more terminology that is often used in GA</div>\r\n                <ul>\r\n                    <li>\r\n                        <b>Multivector</b>: any element of the algebra (eg. {`$1 + 2 e_x + 5 e_{xy}$`})\r\n                        </li>\r\n                    <li>\r\n                        <b>Basis blade</b>: basis vectors and any combination of them\r\n                        (eg. in 2D we have four in total: {`$1, e_x, e_y, e_{xy}$`})\r\n                    </li>\r\n                    <li><b>Grade</b>: the degree of a multivector\r\n                        (eg. $1$ is grade $0$, $e_x$ is grade $1$,\r\n                        $e_x + 5 e_y$ it also grade $1$, {`$e_{xy}$`} is grade $2$)\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n\r\n            <h3>Rotors</h3>\r\n\r\n            <h4>Squaring bivectors</h4>\r\n            <div>\r\n                Now for something more interesting, let's see what happens if we square the bivector {`$e_{xy}$`},\r\n                that is, multiplying it with itself:\r\n            </div>\r\n            <InteractiveCode sourceCode={cnt.codeSquareBivector} />\r\n\r\n            <div>\r\n                {`\\\\begin{equation}\r\n                e_{xy}^2 = e_{xy} e_{xy} = e_{xyxy} = -e_{xyyx} = -e_{xx} = -1\r\n                \\\\end{equation}`}\r\n\r\n                We can see the square of the bivector {`$e_{xy}$`} is $-1$. This shows that such a bivector is\r\n                very similar to the imaginary unit $i$ of complex numbers which was specifically introduced to\r\n                square to $-1$. Here we didn't have to introduce anything new and we automatically had such\r\n                an element in our algebra.\r\n            </div>\r\n\r\n            <br />\r\n\r\n            <div>\r\n                There is still one caveat. While {`$e_{xy}$`} squares to $-1$, so does {`$e_{yx}$`}.\r\n                So which one do we use? Let's try to visualize what multiplying a vector does for both of them\r\n                using {`$v' = e_{xy} v$`} and {`$v' = e_{yx} v$`}.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.codeRotate2DOrientation}\r\n                hideOutput={true} withVisualizer={true}\r\n            />\r\n\r\n            <div>\r\n                We can see that {`$e_{xy}$`} produces a clockwise (CW) rotation by 90° and {`$e_{yx}$`} produces a counter-clockwise (CCW)\r\n                rotation by 90°. We will stick with the CCW version using {`$e_{yx}$`}. Instead of that to make a CCW\r\n                rotation we could have also swapped the order of the product ({`$v' = v e_{xy}$`}) but using {`$e_{yx}$`} instead will allow us to\r\n                follow the usual conventions later.\r\n            </div>\r\n\r\n            <h4>Rotating 2D vectors using rotors</h4>\r\n\r\n            <div>\r\n                As mentioned before {`$e_{yx}$`} can be identified as the imaginary unit $i$ of complex numbers hence\r\n                we can represent complex numbers as {`$a + b e_{yx}$`} and a CCW rotation in the XY plane\r\n                by an arbitrary angle $\\phi$ can be performed just like with complex numbers\r\n                using <a href=\"https://en.wikipedia.org/wiki/Euler%27s_formula\">Euler's formula</a>\r\n\r\n                {`\\\\begin{equation}\r\n                R(\\\\phi) = e^{\\\\phi e_{yx}} = cos(\\\\phi) + e_{yx} sin(\\\\phi)\r\n                \\\\end{equation}`}\r\n\r\n                The object $R$ you get after exponentiating is called a rotor\r\n                (because it rotates when you multiply with it).\r\n\r\n                Unlike with complex numbers now however, we can multiply a vector by a rotor directly instead of\r\n                having to treat vectors as if they were complex numbers.\r\n            </div>\r\n            <InteractiveCode sourceCode={cnt.codeRotate2D}\r\n                hideOutput={true} withVisualizer={true}\r\n            />\r\n            <div>\r\n                {`\\\\begin{equation}\r\n                R(\\\\phi) v = (cos(\\\\phi) + e_{yx} sin(\\\\phi)) (x e_x + y e_y) =\r\n                e_x (x cos(\\\\phi) - y sin(\\\\phi)) + e_y (x sin(\\\\phi) + y cos(\\\\phi))\r\n                \\\\end{equation}`}\r\n            </div>\r\n\r\n            <h4>Higher dimensions</h4>\r\n            <div>\r\n                It turns out that the two dimensional rotor application formula $v' = R v$ was slightly special.\r\n                In the general case it is necessary to use a two sided product\r\n                \r\n                {`\r\n                \\\\begin{equation}\r\n                v' = R v \\\\widetilde{R}\r\n                \\\\end{equation}\r\n                `}\r\n                \r\n                which is also called the sandwich product. {\"$\\\\widetilde{R}$\"} here stands for <a href=\"https://en.wikipedia.org/wiki/Paravector#Reversion_conjugation\">reversion</a> of $R$ which\r\n                just means reversing the order of all basis vectors. For example {\"$e_{yx}$\"} becomes {\"$e_{xy}$\"}.\r\n                As we already know from the second rule of the geometric product, such a change of order just produces a\r\n                minus sign for the bivectors, so {\"$\\\\widetilde{e_{yx}} = -e_{xy}$\"}.\r\n            </div>\r\n            <div>    \r\n                Another thing that changes with the sandwich product\r\n                is that we multiply with the rotor twice, so our rotor will only need to contain half of the rotation angle.\r\n\r\n                {`\r\n                \\\\begin{equation}\r\n                R(\\\\phi) = e^{e_{yx} \\\\frac{\\\\phi}{2}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n\r\n            <div>\r\n                We can now verify that this will indeed give the same results in 2D as the simple one-sided product\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.codeGeneralRotor2D}\r\n                hideOutput={true} withVisualizer={true}\r\n            />\r\n\r\n            <div>\r\n                In the three dimensional case, if we wanted to create\r\n                a rotor that rotates in the XZ plane by $\\phi$ CCW our rotor would look like this:\r\n\r\n                {`\r\n                \\\\begin{equation}\r\n                R(\\\\phi) = e^{e_{zx} \\\\frac{\\\\phi}{2}}\r\n                \\\\end{equation}\r\n                `}\r\n\r\n                We can then also combine rotations in different planes into a single rotor by multiplying them. A rotor that rotates by $\\phi$ CCW in the\r\n                XZ plane followed by a rotation of $\\theta$ CCW in the XY plane looks like this\r\n\r\n                {`\r\n                \\\\begin{equation}\r\n                R(\\\\phi, \\\\theta) = e^{e_{yx} \\\\frac{\\\\theta}{2}} e^{e_{zx} \\\\frac{\\\\phi}{2}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.codeGeneralRotor3D} editorStyle={{height: 350}} />\r\n\r\n            <div>\r\n                These elements that are like the 3D version of complex numbers are called <a href=\"https://en.wikipedia.org/wiki/Quaternion\">quaternions</a>.\r\n            </div>\r\n\r\n            <h4>More on reversion</h4>\r\n            <div>\r\n                Applying the reversion operation on a rotor reverses its effect, for example applying the reversion operation to a rotor that rotates\r\n                by 90° CCW will make it rotate by 90° CW (ie. -90° CCW). A result of this is that a rotor multiplied by its reversal produces the\r\n                identity {`$R \\\\widetilde{R} = 1$`} which does nothing when applied as demonstrated in the code below. Here we also\r\n                make use of the <code>sandwichProduct()</code> function instead of writing the sandwich product\r\n                using <code>geometricProduct()</code> and <code>reversion()</code>.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.codeReversionIdentity} editorStyle={{height: 300}} />\r\n\r\n            <h3>Summary</h3>\r\n            <div>\r\n                <ul>\r\n                    <li><b>Geometric product rule 1</b>: basis vectors square to +1 ({`$e_x e_x = e_{xx} = 1, e_y e_y = e_{yy} = 1$`})</li>\r\n                    <li><b>Geometric product rule 2</b>: different basis vectors anti-commute ({`$e_x e_y = e_{xy} =  -e_{yx} = -e_y e_x$`})</li>\r\n                    <li><b>Rotor in XY plane rotating by $\\phi$ counter-clockwise</b>: {`$R(\\\\phi) = e^{\\\\phi e_{yx}} = cos(\\\\phi) + e_{yx} sin(\\\\phi)$`}</li>\r\n                    <li><b>Reversion</b>: reverse order of basis vectors (eg. {`$e_{xyz} = e_{zyx} = -e_{xyz}$`}), inverts rotors</li>\r\n                    <li><b>Apply Rotor $R$ to $x$ using sandwich product</b>: {`$x' = R x \\\\widetilde{{R}}$`}</li>\r\n                </ul>\r\n            </div>\r\n\r\n            <h3>Conclusion</h3>\r\n            <div>\r\n                In this section we introduced Geometric Algebra. We learnt the basic rules of the Geometric Product and how to work with them.\r\n                We also learnt about rotors which generalize the rotations created by complex numbers to any dimension and also puts them\r\n                directly in the context of vectors.\r\n            </div>\r\n            <br />\r\n            <div>\r\n                In the next section we will learn how we can introduce translation in the rotors so we can do both translation and rotation\r\n                using the same rotor and just one sandwich product. This will prove to have many advantages allow even further generalization.\r\n            </div>\r\n\r\n            <h4><Link to=\"/pga\">Next: Projective Geometric Algebra</Link></h4>\r\n        </div>\r\n    )\r\n}","export const codeRenderPoint = `// Render point at x=10, y=-60\r\nrenderPointGA({ e0: 10, e1: -60 })\r\n\r\n// Render point at x=-50, y=80\r\nrenderPointGA({ e0: -50, e1: 80 }, \"red\")`\r\n\r\nexport const codeSquareBasisVectors = `var exSquared = ga.geometricProduct({ e0: 1 }, { e0: 1 })\r\nvar eySquared = ga.geometricProduct({ e1: 1 }, { e1: 1 })\r\n\r\nlog(\"e0^2:\", exSquared)\r\nlog(\"e1^2:\", eySquared)`\r\n\r\nexport const codeExteriorProduct = `var exEy = ga.geometricProduct({ e0: 1 }, { e1: 1 })\r\nvar eyEx = ga.geometricProduct({ e1: 1 }, { e0: 1 })\r\n\r\nlog(\"e0 e1:\", exEy)\r\nlog(\"e1 e0:\", eyEx)`\r\n\r\nexport const codeAntiCommute = `var exEy = ga.geometricProduct({ e0: 1 }, { e1: 1 })\r\nvar exEyEx = ga.geometricProduct(exEy, { e0: 1 })\r\n\r\nlog(\"e0 e1 e0:\", exEyEx)`\r\n\r\nexport const codeSquareBivector = `var exEy = { e01: 1 }\r\nvar exEySquared = ga.geometricProduct(exEy, exEy)\r\n\r\nlog(\"e01^2\", exEySquared)`\r\n\r\nexport const codeRotate2DOrientation = `var eXy = { e01: 1 }\r\nvar eYx = { e01: -1 } // e_yx = -e_xy\r\n\r\nvar p = { e0: 70, e1: 0 }\r\n\r\nvar a = ga.geometricProduct(eXy, p)\r\nvar b = ga.geometricProduct(eYx, p)\r\n\r\nrenderPointGA(p)\r\nrenderPointGA(a, \"red\")\r\nrenderPointGA(b, \"blue\")\r\n`\r\n\r\nexport const codeRotate2D = `var phi = Math.PI * 3 / 4 // 135°\r\n\r\n// e^(phi e_{yx}) = e^(-phi e_{xy})\r\nvar r = ga.exponential({ e01: -phi })\r\n\r\nvar p = { e0: 70, e1: 0 }\r\n\r\n// p rotated by 135° counter-clockwise\r\nvar rotatedP = ga.geometricProduct(r, p)\r\n\r\nrenderPointGA(p)\r\nrenderPointGA(rotatedP, \"red\")\r\nrenderInfo(ga.repr(rotatedP), \"red\")`\r\n\r\nexport const codeGeneralRotor2D = `var phi = Math.PI * 3 / 4 // 135°\r\n\r\n// e^(phi/2 e_{yx}) = e^(-phi/2 e_{xy})\r\n// Only half the angle required with sandwich product\r\nvar r = ga.exponential({ e01: -phi / 2 })\r\n\r\nvar p = { e0: 70, e1: 0 }\r\n\r\n// R p ~R (sandwich product)\r\n// p rotated by 135° counter-clockwise\r\nvar rotatedP = ga.geometricProduct(\r\n    r,\r\n    ga.geometricProduct(p, ga.reversion(r)) \r\n)\r\n\r\nrenderPointGA(p)\r\nrenderPointGA(rotatedP, \"red\")\r\nrenderInfo(ga.repr(rotatedP), \"red\")`\r\n\r\nexport const codeGeneralRotor3D = `var phi = Math.PI * 3 / 4 // 135°\r\nvar theta = Math.PI / 2 // 90°\r\n\r\n// CCW XZ rotation by phi\r\nvar r1 = ga3d.exponential({ e02: -phi / 2 })\r\n\r\n// CCW XY rotation by theta\r\nvar r2 = ga3d.exponential({ e01: -theta / 2 })\r\n\r\n// Compose XY and XZ rotation\r\nvar r = ga3d.geometricProduct(r2, r1)\r\n\r\nvar p = { e0: 70, e1: 0, e2: 0 }\r\n\r\n// p first rotated by phi in XZ, then by theta in XY\r\nvar rotatedP = ga3d.geometricProduct(\r\n    r,\r\n    ga3d.geometricProduct(p, ga3d.reversion(r))\r\n)\r\n\r\nlog(\"Rotated P:\", rotatedP)`\r\n\r\nexport const codeReversionIdentity = `var phi = Math.PI * 3 / 4 // 135°\r\nvar theta = Math.PI / 2 // 90°\r\n\r\nvar r1 = ga3d.exponential({ e02: -phi / 2 })\r\nvar r2 = ga3d.exponential({ e01: -theta / 2 })\r\n\r\n// Compose XY and XZ rotation\r\nvar r = ga3d.geometricProduct(r2, r1)\r\n\r\nvar p = { e0: 70, e1: 0, e2: 0 }\r\n\r\n// (R ~R) p (R ~P)\r\nvar q = ga3d.sandwichProduct(\r\n    p,\r\n    ga3d.geometricProduct(r, ga3d.reversion(r))\r\n)\r\n\r\nlog(\"q:\", q)`","import React from \"react\"\r\nimport { InteractiveCode } from \"./InteractiveCode\"\r\nimport * as cnt from \"./CodePGATutorial\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { useMathJax } from \"../util\"\r\n\r\nexport function PGATutorial() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Translations</h3>\r\n            <div>\r\n                So far we learnt how to do rotations using rotors. Another important operation is translation. Naively we could\r\n                just use vector addition to achieve translation using some offset vector $d = d_x e_x + d_y e_y$\r\n\r\n                {`\\\\begin{equation}\r\n                v' = v + d\r\n                \\\\end{equation}`}\r\n\r\n                If we have two translation vectors $a$ and $b$ we can combine their action by adding them to get a single translation vector $d = a + b$.\r\n                This all seems very obvious and straightforward.\r\n            </div>\r\n\r\n            <br />\r\n\r\n            <div>\r\n                What if we wanted to do both translation and rotation? Using vector addition for translation and rotors for rotation our operation\r\n                would look like this\r\n\r\n                {`\\\\begin{equation}\r\n                v' = R v \\\\widetilde{R} + d\r\n                \\\\end{equation}`}\r\n\r\n                Now if we wanted to compose two translations and rotations, we would have two rotors $R_1$ and $R_2$ and two translation vectors $d_1$ and $d_2$.\r\n                First we would apply $R_1$ and $d_1$ according to the formula above. Then we would apply $R_2$ and $d_2$ on the result of the previous operation.\r\n\r\n                {`\\\\begin{aligned}\r\n                v' & = R_1 v \\\\widetilde{R_1} + d_1 \\\\\\\\\r\n                v'' & = R_2 v' \\\\widetilde{R_2} + d_2 = R_2 (R_1 v \\\\widetilde{R_1} + d_1) \\\\widetilde{R_2} + d_2\r\n                \\\\end{aligned}`}\r\n\r\n                We could multiply this out but we will get a lot of terms and the operations don't compose as nicely as they did when we had only rotations or translations.\r\n                Is there a way we can do both rotation and translation with a single rotor? Projective Geometric Algebra (PGA) sets out to do this.\r\n            </div>\r\n\r\n            <h3>Projective Geometric Algebra</h3>\r\n            <h5>A new kind of basis vector</h5>\r\n            <div>\r\n                PGA starts with the familiar basis vectors that square to $+1$ and also adds another basis vector $e_0$ one that squares to $0$.\r\n                In two dimensional PGA we thus have basis vectors $e_x$, $e_y$ and $e_0$. As a result there will also be three bivectors {`$e_{0x}, e_{0y}, e_{xy}$`} and one\r\n                trivector {`$e_{0xy}$`}.\r\n            </div>\r\n            <br />\r\n            <div>\r\n                We will see that this strange additional basis vector allows us to encode both rotations and translations in a single rotor and\r\n                also many more things we couldn't easily do before.\r\n            </div>\r\n            <h5>Points</h5>\r\n            <div>\r\n                Another peculiarity of PGA is that points are not encoded as vectors $x e_x + y e_y$ anymore but as\r\n\r\n                {`\\\\begin{equation}\r\n                P = x e_{y0} + y e_{0x} + e_{xy}\r\n                \\\\end{equation}`}\r\n\r\n                In the code below we display some points like before but this time using 2D PGA. The vector $e_0$ is denoted by\r\n                <code>e0</code> and $e_x, e_y$ as <code>e1</code> and <code>e2</code>.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.pgaPoints}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <div>\r\n                In the code we can also see that the rendered point coordinate gets divided by\r\n                the {`$e_{xy}$`} part of the multivector. Multiplying the multivector by a scalar thus\r\n                won't have any effect on which point the multivector encodes as the final position gets\r\n                divided by the {`$e_{xy}$`} part again which was also scaled by the same amount.\r\n            </div>\r\n\r\n            <h5>Translators</h5>\r\n            <div>\r\n                As promised this weird setup will allow us to perform translations using rotors. Rotors that only do\r\n                translation are also called translators and we denote them by $T$.\r\n            </div>\r\n            <div>\r\n                Just like with the rotors we use the exponential function to generate translators from our algebra.\r\n                A translator that moves by $d$ in the X direction is given by {`$T = e^{\\\\frac{d}{2} e_{0x}}$`}.\r\n                If we compare this to the point encoding we will notice that {`$e_{0x}$`} is the bivector related to the\r\n                Y coordinate, so here the translators perform a translation that is orthogonal to the bivector's direction.\r\n                As previously we will apply the translator using the sandwich product.\r\n            </div>\r\n            <div>\r\n                This time to calculate the result of the exponential we can not make use of Euler's formula as it only applies to\r\n                elements that square to $-1$ and the bivector {`$e_{0x}$`} squares to $0$. The equivalent of Euler's formula for\r\n                elements squaring to $0$ is fortunately very simple\r\n\r\n                {`\\\\begin{equation}\r\n                T = e^{\\\\frac{d}{2} e_{0x}} = 1 + \\\\frac{d}{2} e_{0x}\r\n                \\\\end{equation}`}\r\n\r\n                so all we picked up was the additional scalar $1$.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.translators}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <h5>Motors</h5>\r\n            <div>\r\n                We can also compose rotors and translators using multiplications. We call the resulting elements motors and denote them\r\n                by $m$. For example a motor\r\n\r\n                {`\\\\begin{equation}\r\n                m = e^{\\\\frac{\\\\phi}{2} e_{yx}} e^{\\\\frac{d}{2} e_{0x}}\r\n                \\\\end{equation}`}\r\n\r\n                will first perform the translation of the previous example followed by a rotation around the origin in the\r\n                XY plane by $\\phi$ CCW.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.motors}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <div>\r\n                So far we have only been visualizing single points. With points we can not observe the effect that\r\n                rotation has besides how it affects the position of the points. To visualize the rotation we will\r\n                look at how a set of points gets transformed instead, such as a box. When applying a rotor that rotates\r\n                we would expect the box to also rotate. We will use the provided <code>renderBoxPGA()</code> function\r\n                for this purpose. The way it works is that it takes four points that are offset relative to the origin\r\n                and transforms them with the given motor.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.motorsBox}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <div>\r\n                Our motor here produces a CCW rotation of {`$\\\\frac{\\\\pi}{4}$`} (twice the amount written in the code) which\r\n                indeed rotated our box by 45°.\r\n            </div>\r\n\r\n            <h3>Motor interpolation</h3>\r\n            <div>\r\n                A very useful property of PGA is its ability to smoothly interpolate between motors. Previously if we had separate\r\n                translation and rotation (eg. when using vector addition for translation and rotors for rotation) it was not clear how one would\r\n                interpolate between two of such transformations.\r\n            </div>\r\n\r\n            <br />\r\n\r\n            <div>\r\n                Interpolating translations and vectors is easy, for example with linear\r\n                interpolation. If we are given two vectors $v_1, v_2$ and a blending factor $\\alpha$\r\n                the interpolated vector $v(\\alpha)$ is given by\r\n\r\n                {`\\\\begin{equation}\r\n                v(v_1, v_2, \\\\alpha) = (1 - \\\\alpha) v_1 + \\\\alpha v_2\r\n                \\\\end{equation}`}\r\n            </div>\r\n            <div>\r\n                Interpolating rotations and rotors is a bit trickier but still relatively common, for example\r\n                using quaternions and <a href=\"https://en.wikipedia.org/wiki/Slerp\">spherical linear interpolation</a>.\r\n            </div>\r\n\r\n            <div>\r\n                So how do we interpolate between two motors $m_1$ and $m_2$ such as in the following example?\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.motorBlendingMotivation}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <br />\r\n\r\n            <h5>With known exponents</h5>\r\n            <div>\r\n                Thankfully our hard work of learning about motors will pay off here. Imagine we are given the exponents of two\r\n                motors $m_1$ and $m_2$ which we denote by $a_1$ and $a_2$ (ie. {`$m_1 = e^{a_1}, m_2 = e^{a_2}$`}). To get the interpolated\r\n                motor $m(\\alpha)$ all we have to do is linearly interpolate between the exponents and then exponentiate\r\n\r\n                {`\\\\begin{equation}\r\n                m(\\\\alpha) = e^{(1 - \\\\alpha) a_1 + \\\\alpha a_2}\r\n                \\\\end{equation}`}\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.motorBlending}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <div>\r\n                We can see the interpolation produces a curve. If we interpolated translation and rotation separately using\r\n                linear interpolation we would have just gotten a straight line.\r\n            </div>\r\n\r\n            <h5>With unknown exponents</h5>\r\n            <div>\r\n                What if we don't know the exponents of the motors? This would happen for example when we keep composing motors.\r\n                A very practical example where that occurs is if we used a motor to describe the position and rotation\r\n                of a rigidbody in a physics simulation.\r\n            </div>\r\n            <div>\r\n                Just like in usual algebra, we can take the logarithm of an exponential to get its exponent. The logarithm of a\r\n                motor in 2D PGA is given by\r\n\r\n                {`\\\\begin{equation}\r\n                log(m) = \\\\langle \\\\frac{m}{||m||} \\\\rangle_2\r\n                \\\\end{equation}`}\r\n\r\n                where $||m||$ stands for the norm of the motor and $\\langle ... \\rangle_2$ stands for only keeping the\r\n                grade $2$ parts (ie. all bivectors) of the result. $||m||$ can easily be calculated\r\n                as {`$\\\\sqrt{m \\\\widetilde{m}}$`} which results in a scalar.\r\n            </div>\r\n            <div>\r\n                In the code we just take the previous example but instead of given exponents $a_1, a_2$ we will calculate\r\n                them from given motors using the logarithm.\r\n            </div>\r\n\r\n            <InteractiveCode sourceCode={cnt.motorBlendingLog}\r\n                hideOutput={true} withVisualizer={true} />\r\n\r\n            <h3>Summary</h3>\r\n            <div>\r\n                <ul>\r\n                    <li><b>2D PGA basis vectors</b>: $e_0^2 = 0, e_x^2 = 1, e_y^2 = 1$</li>\r\n                    <li><b>Point at $(x, y)$</b>: {`$P = x e_{y0} + y e_{0x} + e_{xy}$`}</li>\r\n                    <li><b>Point coordinates $(x, y)$ from PGA point $P$</b>: {`$(X, Y) = \\\\frac{(P_{y0}, P_{x0})}{P_{xy}}$`}</li>\r\n                    <li><b>Translator by $d$ orthogonal to Y direction {`$e_{0x}$`} (ie. along X direction)</b>: {`$T = e^{\\\\frac{d}{2} e_{0x}}$`}</li>\r\n                    <li><b>Motor</b>: Rotor that both rotates and translates</li>\r\n                    <li><b>Motor logarithm</b>: {`$log(m) = \\\\langle \\\\frac{m}{||m||} \\\\rangle_2$`}</li>\r\n                    <li><b>Interpolate between motors $m_1$ and $m_2$</b>: {`$m(m_1, m_2, \\\\alpha) = e^{(1 - \\\\alpha) log(m_1) + \\\\alpha log(m_2)}$`}</li>\r\n                </ul>\r\n            </div>\r\n\r\n            <h3>Conclusion</h3>\r\n            <div>\r\n                In this section we learnt about PGA where we have a new basis vector $e_0$ which squares to $0$ and\r\n                also a different encoding for our points. This enabled us to perform translations using rotors.\r\n                A rotor which does rotation and translation is also called a motor. This also enabled\r\n                us to interpolate smoothly between motors.\r\n            </div>\r\n            <br />\r\n            <div>\r\n                In the next section we will take a look at how PGA allows us to represent \"flat\" geometric objects such as\r\n                lines and planes, and how it allows us to easily do many operations that would classically look very distinct.\r\n                We will also learn about the concept of duality and how the geometric product decomposes into two separate parts.\r\n            </div>\r\n\r\n            <h4><Link to=\"/pga-geometry\">Next: PGA Geometry</Link></h4>\r\n        </div>\r\n    )\r\n}","export const pgaPoints = `// Render a point at x: 40, y: 60\r\nrenderPointPGA({\r\n    e02: -40, // -e_0y = e_y0\r\n    e01: 60,\r\n    e12: 1\r\n}, \"lime\")\r\n\r\n// Render a point at x: 20, y: 30\r\n// Point coordinates divided by e_xy part\r\nrenderPointPGA({\r\n    e02: -40,\r\n    e01: 60,\r\n    e12: 2\r\n}, \"red\")`\r\n\r\nexport const translators = `var p = {\r\n    e02: -40,\r\n    e01: 60,\r\n    e12: 1\r\n}\r\n\r\n// Translator that moves by 80 along X.\r\n// Same as exp(d/2 e_0y).\r\nvar t = {\r\n    scalar: 1,\r\n    e01: 40\r\n}\r\n\r\nvar q = pga.sandwichProduct(p, t)\r\n\r\nrenderPointPGA(p, \"lime\")\r\nrenderPointPGA(q, \"red\")`\r\n\r\nexport const motors = `var p = {\r\n    e02: -40,\r\n    e01: 60,\r\n    e12: 1\r\n}\r\n\r\nvar t = pga.exponential({\r\n    e01: 40\r\n})\r\n\r\nvar r = pga.exponential({\r\n    // 90°/2; e_yx = -e_xy\r\n    e12: -Math.PI / 4\r\n})\r\n\r\nvar m = pga.geometricProduct(r, t)\r\n\r\nvar q = pga.sandwichProduct(p, m)\r\n\r\nrenderPointPGA(p, \"lime\")\r\nrenderPointPGA(q, \"red\")`\r\n\r\nexport const motorsBox = `var t = pga.exponential({\r\n    e01: 40\r\n})\r\n\r\nvar r = pga.exponential({\r\n    e12: -Math.PI / 8\r\n})\r\n\r\n// Translate -80 in X, then rotate 45° CCW\r\nvar m = pga.geometricProduct(r, t)\r\n\r\n// Identity motor to visualize the initial box\r\n// at the origin\r\nvar identity = { scalar: 1 }\r\n\r\nrenderBoxPGA(identity, \"lime\")\r\nrenderBoxPGA(m, \"red\")`\r\n\r\nexport const motorBlendingMotivation = `var a1 = {\r\n    e01: 40,\r\n    e02: 30\r\n}\r\n\r\nvar a2 = {\r\n    e01: -40,\r\n    e02: -10,\r\n    e12: -Math.PI / 6\r\n}\r\n\r\nvar m1 = pga.exponential(a1)\r\nvar m2 = pga.exponential(a2)\r\n\r\nrenderBoxPGA(m1, \"black\")\r\nrenderBoxPGA(m2, \"red\")`\r\n\r\nexport const motorBlending = `var a1 = {\r\n    e01: 40,\r\n    e02: 30\r\n}\r\n\r\nvar a2 = {\r\n    e01: -40,\r\n    e02: -10,\r\n    e12: -Math.PI / 6\r\n}\r\n\r\nfor (var alpha = 0; alpha <= 1; alpha += 0.1) {\r\n    var m = pga.exponential(pga.add(\r\n        pga.geometricProduct(a1, { scalar: 1 - alpha }),\r\n        pga.geometricProduct(a2, { scalar: alpha })\r\n    ))\r\n    var c = \"rgb(\" + (255 * alpha).toString() + \", 0, 0)\"\r\n    renderBoxPGA(m, c)\r\n}`\r\n\r\nexport const motorBlendingLog = `var m1 = { scalar: 1, e01: 20, e02: 40 }\r\nvar m2 = { scalar: 1, e01: -250, e12: -Math.PI * 1.3 }\r\n\r\nfunction motorLog(m) {\r\n    var divisor = Math.sqrt(\r\n        pga.geometricProduct(\r\n            m,\r\n            pga.reversion(m)\r\n        ).scalar\r\n    )\r\n    var allGrades = pga.div(m, divisor)\r\n    return {\r\n        e01: allGrades.e01,\r\n        e02: allGrades.e02,\r\n        e12: allGrades.e12\r\n    }\r\n}\r\n\r\nvar a1 = motorLog(m1)\r\nvar a2 = motorLog(m2)\r\nrenderInfo(\"a1: \" + pga.repr(a1))\r\nrenderInfo(\"a2: \" + pga.repr(a2))\r\n\r\nfor (var alpha = 0; alpha <= 1; alpha += 0.1) {\r\n    var m = pga.exponential(pga.add(\r\n        pga.geometricProduct(a1, { scalar: 1 - alpha }),\r\n        pga.geometricProduct(a2, { scalar: alpha })\r\n    ))\r\n    var c = \"rgb(\" + (255 * alpha).toString() + \", 0, 0)\"\r\n    renderBoxPGA(m, c)\r\n}`\r\n\r\nexport const visualizerExample = `// Render a point at x: 50, y: 10\r\nrenderPointPGA({\r\n    e02: -50,\r\n    e01: 10,\r\n    e12: 1\r\n}, \"lime\")\r\n\r\n// Render the line 2x + 1y - 10 = 0\r\nrenderLinePGA({\r\n    e0: -10,\r\n    e1: 2,\r\n    e2: 1\r\n}, \"orange\")`","import React from \"react\"\r\n\r\nexport function PGAGeometryTutorial() {\r\n    return (\r\n        <div>\r\n            <h4>Projective Geometric Algebra Geometry</h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\n\r\nexport function CoffeeShop(props: { id: string, title?: string }) {\r\n    const { id, title } = props\r\n\r\n    const url = `https://enkimute.github.io/ganja.js/examples/coffeeshop.html#${id}`\r\n\r\n    return (\r\n        <div>\r\n            <iframe src={`${url}&amp;fullscreen`} title={title} width=\"100%\" height=\"600px\" frameBorder={0}>\r\n            </iframe>\r\n            <sub><a href={url}>Link to CoffeeShop with code</a></sub>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { useMathJax } from \"../util\"\r\nimport { CoffeeShop } from \"./CoffeeShop\"\r\n\r\nexport function GADesign1() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Designing Geometric Algebras - Shapes</h3>\r\n            <div>\r\n                Typically we choose a Geometric Algebra that will work well with our problem.\r\n                First there are the object types the different GAs can represent.\r\n                If we want flat objects such as lines and planes going through the origin ordinary GA works.\r\n                If we additionally want the objects to be at arbitrary positions PGA is a good choice.\r\n                For spheres we can choose CGA which can directly represent them.\r\n                Secondly we might need certain operations which also dictates our choice of GA.\r\n                Ordinary GA has rotors that can do rotations only.\r\n                With both PGA and CGA we get rotors which can do translation and rotation.\r\n\r\n                Below is a table of a few already explored GAs and their properties.\r\n\r\n                <table style={{ width: \"100%\", padding: \"2%\" }}>\r\n                    <tr>\r\n                        <th style={{ textAlign: \"left\" }}>Name</th>\r\n                        <th style={{ textAlign: \"left\" }}>Signature</th>\r\n                        <th style={{ textAlign: \"left\" }}>Objects</th>\r\n                        <th style={{ textAlign: \"left\" }}>Rotors</th>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>Ordinary GA</td>\r\n                        <td>N, 0, 0</td>\r\n                        <td>Flat (through origin)</td>\r\n                        <td>Rotation</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>Projective Geometric Algebra</td>\r\n                        <td>N, 0, 1</td>\r\n                        <td>Flat</td>\r\n                        <td>Rotation, Translation</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>Conformal Geometric Algebra</td>\r\n                        <td>N+1, 1, 0</td>\r\n                        <td>Flat, Round</td>\r\n                        <td>Rotation, Translation</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td><a href=\"https://link.springer.com/article/10.1007/s00006-018-0879-2\">Conic Geometric Algebra</a></td>\r\n                        <td>5, 3, 0</td>\r\n                        <td>Conics (2D)</td>\r\n                        <td>Rotation, Translation, Uniform scaling</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td><a href=\"https://www.researchgate.net/publication/324067465_Quadric_Conformal_Geometric_Algebra_of_mathbb_R96R96\">Quadric Geometric Algebra</a></td>\r\n                        <td>9, 6, 0</td>\r\n                        <td>Quadrics (3D)</td>\r\n                        <td>Rotation, Translation, Uniform scaling</td>\r\n                    </tr>\r\n                </table>\r\n\r\n                So if what we need is contained in one of these we can simply use them and\r\n                benefit from the previous exploration done within them.\r\n                What if we need something that is not contained in one of these pre-made\r\n                GAs though? Is there a way to create exactly what we need?\r\n                \r\n                In the first part of this article we will try to figure out how to create a\r\n                GA that contains the objects we want. Specifically we will try to create a\r\n                GA containing arbitrary polynomial shapes such as parabolas and <a href=\"https://en.wikipedia.org/wiki/Elliptic_curve\">elliptic curves</a>.\r\n                In the second part we will also look at the rotors.\r\n            </div>\r\n\r\n            <h4>How are objects represented outside of GA?</h4>\r\n            <div>\r\n                <div>\r\n                    Before jumping into GA we should take a step back and remember how we represented \r\n                    objects in algebra before.\r\n                </div>\r\n                <div>\r\n                    Usually we represent a 2D line by the linear equation $y = a x + b$, a circle at the origin\r\n                    by $x^2 + y^2 = r^2$ and so on. Rearranging this a bit to bring everything to the same\r\n                    side we get equivalently $ax + b - y = 0$ and $x^2 + y^2 - r^2 = 0$. The object is then\r\n                    represented by all the points $(x, y)$ for which these equations are true, that is, for which\r\n                    the left hand side evaluates to zero. We call this the null space or kernel of the function.\r\n                </div>\r\n            </div>\r\n\r\n            <h4>Object representation in GA</h4>\r\n            <div>\r\n                <div>\r\n                    Now jumping to GA, in 2D PGA a point is represented by a bivector {`$x e_{0y} + y e_{x0} + 1 e_{xy}$`} and \r\n                    a line is represented by a vector {`$x e_x + y e_y - d e_0$`}. Let's call the mapping for points\r\n                    the $up$  function:\r\n                    {`\\\\begin{equation}\r\n                    up: \\\\mathbb{R}^N \\\\mapsto \\\\mathbb{Cl}(...)\r\n                    \\\\end{equation}`}\r\n\r\n                    Here's a table of the previously mentioned algebras and their up functions. Note that some of these use a dual representation \r\n                    for points (points as pseudovectors) and some use the usual representation (points as vectors).\r\n\r\n                    <table style={{ width: \"100%\", padding: \"2%\" }}>\r\n                        <tr>\r\n                            <th style={{ textAlign: \"left\" }}>Name</th>\r\n                            <th style={{ textAlign: \"left\" }}>Up</th>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Ordinary GA</td>\r\n                            <td>$x e_x + y e_y + z e_z + ...$</td>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Projective Geometric Algebra</td>\r\n                            <td>$x e_x^* + y e_y^* + ... + 1 e_0^*$</td>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Conformal Geometric Algebra</td>\r\n                            <td>$1 e_o + x e_x + y e_y + ... + \\frac{1}{2} (x^2 + y^2 + ...) e_\\infty$</td>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Conic Geometric Algebra</td>\r\n                            <td>{`$e_{o+} + x e_x + y e_y + \\\\frac{1}{2} (x^2 + y^2) e_{\\\\infty +} + \\\\frac{1}{2} (x^2 - y^2) e_{\\\\infty +} + x y e_{\\\\infty \\\\times}$`}</td>\r\n                        </tr>\r\n                        <tr>\r\n                            <td>Quadric Geometric Algebra</td>\r\n                            <td>{`$x e_x + ... + \\\\frac{1}{2} (x^2 e_{\\\\infty 1} + ...) + x y e_{\\\\infty 4} + ... + 1 e_{o 1} + ... $`}</td>\r\n                        </tr>\r\n                    </table>\r\n\r\n                    How do we connect these representations to the usual null-space representation?\r\n                    There are two almost equivalent ways of doing this.\r\n                </div>\r\n                <h5>Inner Product Null Space Representation</h5>\r\n                <div>\r\n                    The first one is the Inner Product Null Space (IPNS) representation. Here we say that the inner product\r\n                    of our object, let's call it $o$, is zero for an arbitrary point produced by our up function.\r\n\r\n                    {`\\\\begin{equation}\r\n                    up(...) \\\\cdot o = 0\r\n                    \\\\end{equation}`}\r\n                    \r\n                    The IPNS representation has the downside that we need to define a metric so the inner product works.\r\n                    This means that the representation depends on what our basis vectors square to. This also doesn't work\r\n                    for degenerate metrics such as the one used by PGA.\r\n                </div>\r\n                <h5>Outer Product Null Space Representation</h5>\r\n                <div>\r\n                    The second representation is the Outer Product Null Space (OPNS) representation. Instead of the inner product \r\n                    we use the outer product which means we don't need to define a metric either and this will work the same regardless \r\n                    of what our basis vectors square to. We wedge our object $o$ with an arbitrary point produced by our up function.\r\n\r\n                    {`\\\\begin{equation}\r\n                    up(...) \\\\wedge o = 0\r\n                    \\\\end{equation}`}\r\n\r\n                    The intuition here is that if points are represented by vectors then $\\wedge$ represents the join operation. If \r\n                    we try to join a point that already lies on the object we get zero. Note that if we're using a dual representation \r\n                    (points as pseudovectors) then we need to use $\\vee$ instead as that is then the join operation (maybe a better name \r\n                    would then be the Vee Product Null Space (VPNS)? Or Join Null Space (JNS) for the general case). \r\n                </div>\r\n                <div>\r\n                    We will continue using OPNS from now on and apply it to recover more familiar equations for the objects.\r\n                </div>\r\n                <h5>Example: OPNS applied to PGA 2D</h5>\r\n                <div>\r\n                    Let's apply the OPNS equation to see what a vector in 2D PGA represents. For the arbitrary $X$ \r\n                    we need to use a pseudovector. The $up(x, y)$ function gives us a pseudovector (bivector in this case) \r\n                    so let's use it in place of $X$ and remember that we need to use $\\vee$ for dual representations.\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) \\\\vee vector & = (x e_{0y} + y e_{x0} + 1 e_{xy}) \\\\vee (a e_x + b e_y + d e_0) \\\\\\\\\r\n                    & = a x + b y + d = 0\r\n                    \\\\end{aligned}`}\r\n\r\n                    We have recovered the usual equation for a line. Unlike the previous one, this one also has a coefficient for $y$ which makes \r\n                    it possible to represent vertical lines (by setting $b = 0$ we get $a x = -d$). Hence the vectors in 2D PGA represent lines.\r\n                </div>\r\n                <div>\r\n                    What happens when we apply the OPNS to PGA points (pseudovectors, bivectors in 2D)?\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) \\\\vee point & = (x e_{0y} + y e_{x0} + 1 e_{xy}) \\\\vee (a e_{0y} + b e_{x0} + c e_{xy}) \\\\\\\\\r\n                    & = b x e_0 + c x e_y - a y e_0 + c y e_x - a e_y - b e_x  \\\\\\\\\r\n                    & = e_y (c x - a) + e_x (c y - b) + e_0 (b x - a y)\r\n                    \\\\end{aligned}`}\r\n\r\n                    We get three equations that have to vanish, only two of which are independent.\r\n\r\n                    {`\\\\begin{aligned}\r\n                    & c x - a = 0 & \\\\implies x = \\\\frac{a}{c} \\\\\\\\\r\n                    & c y - b = 0 & \\\\implies y = \\\\frac{b}{c} \\\\\\\\\r\n                    & b x - a y = b \\\\frac{a}{c} - a y = 0 & \\\\implies y = \\\\frac{b}{c}\r\n                    \\\\end{aligned}`}\r\n\r\n                    The coordinates we extract get divided by the {`$e_{xy}$`} part of the point. We automatically get homogeneous space and\r\n                    projective points just by defining the up function the way we did with the constant coefficient term {`$1 e_{xy}$`}.\r\n                </div>\r\n                <div>\r\n                    As a final note, applying OPNS is like finding an inverse for the up function. For points it indeed gives \r\n                    the inverse mapping (ie. as if we just inverted the function directly) but the OPNS also generalizes it to \r\n                    apply to elements other than points in a consistent manner.\r\n                </div>\r\n            </div>\r\n\r\n            <h4>Representing polynomials in GA</h4>\r\n            <div>\r\n                Looking at how we arrived at the equation for a line from the OPNS equation we can see that the \r\n                coefficients $a, b, d$ came from the object whose representation we're trying to understand, but the \r\n                variables $x$, $y$ and $1$ (for $d$) came from how we defined the $up$ function.\r\n                This means that if we wanted to represent different shapes we need to change the $up$ function.\r\n            </div>\r\n            <div>\r\n                As an example, if we wanted to represent parabolas, we would need to have a basis vector that has $x^2$ as a \r\n                coefficient in $up$. For example {`$up(x, y) = x^2 e_{0y} + y e_{x0} + 1 e_{xy}$`} \r\n                would give us $a x^2 + b y + d = 0$ after applying the OPNS equation.\r\n            </div>\r\n            <div>\r\n                Another interesting observation here is that we have a constant term in the polynomial \r\n                which comes from the fact that we add a constant bivector {`$1 e_{xy}$`} \r\n                in the up function. This allows PGA to represent translated objects unlike ordinary GA which \r\n                can only represent objects through the origin.\r\n            </div>\r\n            <div>\r\n                Furthermore the number of basis vectors is arbitrary. For each term we want we can simply add another basis vector \r\n                with our desired coefficient.\r\n                Finally as already mentioned before, the OPNS does not depend on the metric so the interpretation works \r\n                regardless of what the basis vectors square to.\r\n            </div>\r\n\r\n            <h5>Example: Elliptic curves in GA</h5>\r\n            <div>\r\n                Looking at the <a href=\"https://en.wikipedia.org/wiki/Elliptic_curve\">Wikipedia article for elliptic curves</a> \r\n                we can find that the equation for an elliptic curve is $y^2 = x^3 + a x + b 1$. So to represent them we need \r\n                4 terms in our up function with coefficients $y^2, x^3, x, 1$. As a result we will need 4 basis vectors (with any signature). \r\n\r\n                {`\\\\begin{aligned}\r\n                up(x, y) & = x^3 e_1^* + y^2 e_2^* + x e_3^* + 1 e_4^* \\\\\\\\\r\n                & = x^3 e_{234} + y^2 e_{134} + x e_{124} + 1 e_{123}\r\n                \\\\end{aligned}`}\r\n\r\n                Vectors will now be able to represent elliptic curves as well as other simpler curves (parabolas, cubics, lines, ...).\r\n                You can verify this by hand (or ideally using symbolic math software) by applying the OPNS equation to a vector as \r\n                before in the 2D PGA example.\r\n\r\n                <CoffeeShop id=\"aEncZBjgb\" title=\"Elliptic curves in GA\" />\r\n            </div>\r\n\r\n            <h4>Join and meet</h4>\r\n            <div>\r\n                <div>\r\n                    If points are represented by vectors the join is $\\wedge$ and meet is $\\vee$.\r\n                    In algebras that uses a dual representation for points such as PGA this is swapped and join is $\\vee$ \r\n                    and meet is $\\wedge$.\r\n                </div>\r\n                <div>\r\n                    Something interesting happens when we look at the meet operation which returns the intersection object of two objects.\r\n                    In PGA when we intersected two straight lines we get a single point (or point at infinity if the lines are parallel).\r\n                    However with more complicated curves such as parabolas or elliptic curves we will get more than one intersection point.\r\n                    For example intersecting a parabola with a line (assuming they intersect) will result in two points.\r\n                    However the representation for such a point pair is identical to the representation of a single point in PGA.\r\n                    The difference will only be visible once we apply the OPNS equation to find out what our object is actually representing.\r\n                </div>\r\n                <h5>Example: parabola at origin intersects horizontal line</h5>\r\n                <div>\r\n                    Let's apply what we have just learnt and look at some actual results to see if they make sense.\r\n                    We want to intersect a parabola at the origin of the form $y = a x^2$ with a horizontal line of the form \r\n                    $y = c 1$. We would expect the intersection to contain 2 points (assuming they intersect).\r\n                </div>\r\n                <div>\r\n                    From the two equations we see that we need the terms $x^2$, $y$ and $1$ and thus we require 3 basis vectors. We'll use a dual \r\n                    representation (points as pseudovectors) and define our up function as follows\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) & = x^2 e_1^* + y e_2^* + 1 e_3^* \\\\\\\\\r\n                    & = x^2 e_{23} + y e_{31} + 1 e_{12}\r\n                    \\\\end{aligned}`}\r\n\r\n                    Now curves should be represented by vectors. For our parabola $p$ we need the $x^2$ and $y$ basis vectors, that is $e_1$ and $e_2$ respectively.\r\n                    For our line $l$ we will need the $y$ and $1$ basis vectors, that is $e_2$ and $e_3$ respectively.\r\n\r\n                    {`\\\\begin{aligned}\r\n                    p & = a e_1 - e_2 \\\\\\\\\r\n                    l & = -e_2 + b e_3\r\n                    \\\\end{aligned}`}\r\n\r\n                    Let's look at the OPNS (using $\\vee$) for $p$ to confirm it indeed represents the desired parabola.\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) \\\\vee p & = (x^2 e_1^* + y e_2^* + 1 e_3^*) \\\\vee (a e_1 - e_2) \\\\\\\\\r\n                    & = a x^2 - y = 0 \\\\\\\\\r\n                    \\\\end{aligned}`}\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) \\\\vee l & = (x^2 e_1^* + y e_2^* + 1 e_3^*) \\\\vee (-e_2 + b e_3) \\\\\\\\\r\n                    & = b - y = 0 \\\\\\\\\r\n                    \\\\end{aligned}`}\r\n\r\n                    Looks like we're good! Now we can intersect the two objects using $\\wedge$ as that is the meet operation in the dual representation.\r\n                    We will call the intersection object $i$.\r\n                    \r\n                    {`\\\\begin{aligned}\r\n                    i = p \\\\wedge l = -a e_{12} + a b e_{13} - b e_{23}\r\n                    \\\\end{aligned}`}\r\n\r\n                    Now let's look at the OPNS of the intersection object to see if it gives us what we expect (two points of intersection).\r\n\r\n                    {`\\\\begin{aligned}\r\n                    up(x, y) \\\\vee i & = (x^2 e_1^* + y e_2^* + 1 e_3^*) \\\\vee (-a e_{12} + a b e_{13} - b e_{23}) \\\\\\\\\r\n                    & = a (-b + y) e_1 + (-a x^2 + b) e_2 + b (a x^2 - y) e_3 = 0\r\n                    \\\\end{aligned}`}\r\n\r\n                    Now we have three vectors that need to each be equal to zero.\r\n\r\n                    {`\\\\begin{aligned}\r\n                    a (-b + y) = 0 & \\\\implies y = b \\\\\\\\\r\n                    (-a x^2 + b) = 0 & \\\\implies x^2 = \\\\frac{b}{a} \\\\\\\\\r\n                    b (a x^2 - y) = 0 & \\\\implies x^2 = \\\\frac{y}{a} \\\\\\\\\r\n                    \\\\end{aligned}`}\r\n\r\n                    The three equations aren't independent (combining the first and third one gives the second one). So now we see that \r\n                    the intersection object represents {`$x^2 = \\\\frac{b}{a}$`} and $y = b$. This has two solutions {`$x_{1,2} = \\\\pm \\\\sqrt{\\\\frac{b}{a}}$`} as expected \r\n                    and the solutions are the correct ones too (eg. $y$ is just the vertical offset $b$ of the line).\r\n                </div>\r\n                <div>\r\n                    Great, we have shown that what we learnt makes sense and can be applied without much thought required. We can even plot the solutions \r\n                    using a library that can plot the null space of the algebraic equations implicitly.\r\n                    \r\n                    <CoffeeShop id=\"CHBV5IJ4J\" title=\"Parabola intersects line in GA\" />\r\n                </div>\r\n                <h5>Example: Intersecting Elliptic Curves</h5>\r\n                <div>\r\n                    Here's another fun example to demonstrate join and meet on elliptic curves.\r\n\r\n                    <CoffeeShop id=\"jDEasJlYu\" />\r\n                    \r\n                    We have a dynamic black curve that interpolates between the blue and the red one using rotors which will be explained in the next part. \r\n                    The black curve intersected with the red curve gives the green points. \r\n                    The teal points oscillate around the center. Teal joined with green gives the pink curve.\r\n                </div>\r\n            </div>\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We have learnt how to represent arbitrary polynomials using GA and that intersection and joining them works and makes sense. \r\n                There are some other things that we could explore. For example nothing stops us from using more complicated up functions than \r\n                polynomials and there is no reason they should not make sense anymore.\r\n            </div>\r\n            <div>\r\n                The major thing we are still missing are operations on objects such as rotation and translation for which we want rotors. \r\n                For these the metric and whether we use a dual representation or not will actually matter. That will be the topic of the next section.\r\n            </div>\r\n            <h4><Link to=\"/ga-design-2\">Next: Design of Geometric Algebras - Rotors</Link></h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { useMathJax } from \"../util\"\r\nimport { CoffeeShop } from \"./CoffeeShop\"\r\n\r\nexport function GADesign2() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Designing Geometric Algebras - Rotors</h3>\r\n            <div>\r\n                In the first part of this series we learnt how to create geometric algebras that\r\n                can represent arbitrary objects. In this second part we will learn about how to\r\n                create the rotors we want to perform translation, rotation and so on.\r\n            </div>\r\n            <h4>Rotor Recap</h4>\r\n            <div>\r\n                With each pair of basis vectors we can form a bivector. The bivector can be exponentiated which results\r\n                in a rotor that, when an object is sandwiched with it, will perform one of three operations depending\r\n                on what the bivector $B$ squares to:\r\n\r\n                <table style={{ width: \"100%\", padding: \"2%\" }}>\r\n                    <tr>\r\n                        <th style={{ textAlign: \"left\" }}>$B^2$</th>\r\n                        <th style={{ textAlign: \"left\" }}>{`$e^{t B}$`}</th>\r\n                        <th style={{ textAlign: \"left\" }}>Sandwich action on vector</th>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>-1</td>\r\n                        <td>$cos(t) + B sin(t)$</td>\r\n                        <td>Rotates between B's two vectors</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>0</td>\r\n                        <td>$1 + t B$</td>\r\n                        <td>Translates orthogonal to B's two vectors</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>+1</td>\r\n                        <td>$cosh(t) + B sinh(t)$</td>\r\n                        <td><a href=\"https://en.wikipedia.org/wiki/Lorentz_transformation#Physical_formulation_of_Lorentz_boosts\">Boosts</a> between B's two vectors</td>\r\n                    </tr>\r\n                </table>\r\n\r\n                Let's take a look at ordinary 3-space GA. We have three basis vectors $e_x, e_y, e_z$ that each square to +1.\r\n                We have three bivectors {`$e_{xy}, e_{yz}, e_{xz}$`} that each square to -1. Thus the bivectors perform a rotation\r\n                in their planes, meaning, between the components of the two basis vectors they are composed of when applied with the\r\n                sandwich product to a vector.\r\n            </div>\r\n            <h4>Rotors for different up functions</h4>\r\n            <div>\r\n                With a more complicated up function this is no different. The bivectors will still eg. rotate between two components of two\r\n                basis vectors. The result looks more interesting though. If we have a basis vector for the $x^2$ term and another basis vector\r\n                for a constant term, we can rotate between a parabola and a straight line! This is demonstrated below with an algebra that has 3 basis\r\n                vectors and corresponding terms in the up function $x^2, y, 1$.\r\n\r\n                <div style={{ padding: \"2%\" }}>\r\n                    <CoffeeShop id=\"j6gKZCgwS\" title=\"Parabola and line rotor example\" />\r\n                </div>\r\n\r\n                Here's another example where we rotate an elliptic curve into vertical lines (the algebra can represent vertical line tuples).\r\n\r\n                <div style={{ padding: \"2%\" }}>\r\n                    <CoffeeShop id=\"siFF2jGCi\" title=\"Elliptic curve rotor example\" />\r\n                </div>\r\n            </div>\r\n            <h4>Basis vectors as mirrors</h4>\r\n            <div>\r\n                If you've seen <a href=\"https://www.youtube.com/watch?v=ichOiuBoBoQ\">Steven De Keninck's presentation on dual quaternions</a> you \r\n                have seen how the rotors arise naturally from viewing the action of the basis vectors as mirrors in the dual view. \r\n                For example using ordinary 3-space again, each basis vector when applied with the sandwich product will \r\n                reflect the components along its axis.\r\n            </div>\r\n            <div>\r\n                As you might have hoped or expected, nothing changes. If we reflect in a basis vector that has an $x^2$ coefficient in the up function, \r\n                sandwiching with that basis vector will reflect in a parabola instead of a line. This is hard to visualize, \r\n                especially for understanding how the rotors arise from these mirrors but it does all work out the same.\r\n            </div>\r\n            <h4>Rotor exploration</h4>\r\n            <b style={{color: \"red\"}}>\r\n                Here are some things I tried. I might remove this section later or move it to a new page once I figure out a good pattern \r\n                for constructing our desired rotors. Beware of mistakes.\r\n            </b>\r\n            <h5>PGA-like rotors for rotation and translation</h5>\r\n            <div>\r\n                Depending on what our basis vectors square to we will get different squares for the bivectors. This makes it tricky \r\n                to get all the transformations we want. For example we can't easily get both rotation between $e_1, e_2$ and translation \r\n                orthogonal to it.\r\n            </div>\r\n            <div>\r\n                However we can introduce a new basis vector $e_3$ that squares to zero and add it to our up function with a constant coefficient. \r\n                Assuming our two basis vectors $e_1, e_2$ we started with both square to one, we get rotors for rotation between $e_1, e_2$ as \r\n                well as translations in either direction if we sandwich with the exponential of the dual of a vector.\r\n                For example {`$e^{\\\\frac{d}{2} e_1^*} = 1 + \\\\frac{d}{2} e_1^*$`} is a translator (a rotor \r\n                doing translation) in the 1-direction by $d$ when applied with the sandwich product.\r\n            </div>\r\n            <h5>Shear rotors</h5>\r\n            <div>\r\n                So far this was all relatively specific to the up function used by PGA where the extra basis vector has a constant \r\n                coefficient. How does the action of such a rotor look like if the coefficient is not a constant?\r\n            </div>\r\n            <div>\r\n                Let's look at the simple case with two basis vectors and up function $up(x, y) = x e_1 + y e_2$ and $e_1^2 = 1$ but $e_2^2 = 0$.\r\n                We have the bivector {`$e_{12}$`} which squares to zero. When we exponentiate it and apply it with the sandwich product to a vector \r\n                we get\r\n\r\n                {`\\\\begin{aligned}\r\n                & (1 + \\\\frac{d}{2} e_{12}) (x e_1 + y e_2) (1 - \\\\frac{d}{2} e_{12}) \\\\\\\\\r\n                = & (1 + \\\\frac{d}{2} e_{12}) (x e_1 + y e_2 - \\\\frac{d}{2} x e_2) \\\\\\\\\r\n                = & x e_1 + y e_2 - d x e_2 \\\\\\\\\r\n                = & x e_1 + (y - d x) e_2\r\n                \\\\end{aligned}`}\r\n\r\n                It does some sort of translation in the $e_2$ direction proportional to the $e_1$ value. \r\n                For $x = 0$ the $e_2$ direction is unaffected. The bigger the $e_1$ component gets the more \r\n                the $e_2$ direction gets translated. This is a shear in the $e_2$ direction, the vector which \r\n                squares to zero.\r\n            </div>\r\n            <h5>\"Opposite-PGA\" exploration</h5>\r\n            <div>\r\n                <div>\r\n                    Let's try the previous PGA rotor example but instead make $e_1^2 = e_2^2 = 0$ and $e_3^2 = 1$.\r\n                </div>\r\n                <br />\r\n                <div>\r\n                    Applying {`$e_{13}$`} to a vector (line)\r\n\r\n                    {`\\\\begin{aligned}\r\n                    & (1 + \\\\frac{d}{2} e_{13}) (x e_1 + y e_2 + 1 e_3) (1 - \\\\frac{d}{2} e_{13}) \\\\\\\\\r\n                    = & (1 + \\\\frac{d}{2} e_{12}) (x e_1 + y e_2 + 1 e_3 + \\\\frac{d}{2} e_1 + \\\\frac{d}{2} y e_{123}) \\\\\\\\\r\n                    = & x e_1 + y e_2 + 1 e_3 + d e_1 + d y e_{123} \\\\\\\\\r\n                    = & (x + d) e_1 + y e_2 + 1 e_3 + d y e_{123}\r\n                    \\\\end{aligned}`}\r\n\r\n                    This does translation in the $e_1$ direction and also some kind of shear in {`$e_{123}$`} proportional to the $e_2$ component.\r\n                    $e_23$ does the same thing but with $e_1$ and $e_2$ swapped.\r\n                </div>\r\n                <br />\r\n                <div>\r\n                    Applying {`$e_{12}$`} to a vector (line):\r\n                    \r\n                    {`\\\\begin{aligned}\r\n                    & (1 + \\\\frac{d}{2} e_{12}) (x e_1 + y e_2 + 1 e_3) (1 - \\\\frac{d}{2} e_{12}) \\\\\\\\\r\n                    = & (1 + \\\\frac{d}{2} e_{12}) (x e_1 + y e_2 + 1 e_3 - \\\\frac{d}{2} e_{123}) \\\\\\\\\r\n                    = & x e_1 + y e_2 + 1 e_3 - d e_{123}\r\n                    \\\\end{aligned}`}\r\n\r\n                    This does translation in {`$e_{123}$`}.\r\n                </div>\r\n                <br />\r\n                <div>\r\n                    Applying {`$e_{12}$`} to a bivector (point):\r\n\r\n                    {`\\\\begin{aligned}\r\n                    & (1 + \\\\frac{d}{2} e_{12}) (x e_{31} + y e_{23} + 1 e_{12}) (1 - \\\\frac{d}{2} e_{12}) \\\\\\\\\r\n                    = & (1 + \\\\frac{d}{2} e_{12}) (x e_{31} + y e_{23} + 1 e_{12}) \\\\\\\\\r\n                    = & x e_{31} + y e_{23} + 1 e_{12}\r\n                    \\\\end{aligned}`}\r\n\r\n                    This is the identity map.\r\n                </div>\r\n                <br />\r\n                <div>\r\n                    Applying {`$e_{13}$`} to a bivector (point):\r\n\r\n                    {`\\\\begin{aligned}\r\n                    & (1 + \\\\frac{d}{2} e_{13}) (x e_{31} + y e_{23} + 1 e_{12}) (1 - \\\\frac{d}{2} e_{13}) \\\\\\\\\r\n                    = & (1 + \\\\frac{d}{2} e_{12}) (x e_{31} + y e_{23} + 1 e_{12} + \\\\frac{d}{2} y e_{12}) \\\\\\\\\r\n                    = & x e_{31} + y e_{23} + 1 e_{12} + d y e_{12} \\\\\\\\\r\n                    = & x e_{31} + y e_{23} + (1 + d y) e_{12}\r\n                    \\\\end{aligned}`}\r\n\r\n                    This is a shear in the {`$e_{12}$`} direction proportional to the {`$e_{23}$`} component. \r\n                    The last bivector {`$e_{23}$`} will do the same thing in the but proportional to the {`$e_{13}$`} component.\r\n                    Since this is a projective point (which follows from inverting the up function, not conjecture!) \r\n                    it's a division of both x and y by $1 + x$ or $1 + y$. Also composing the two rotors will give us the following:\r\n\r\n                    {`\\\\begin{aligned}\r\n                    & R = (1 + \\\\frac{d_x}{2} e_{23})(1 + \\\\frac{d_y}{2} e_{13}) = 1 + \\\\frac{d_x}{2} e_{23} + \\\\frac{d_y}{2} e_{13} + \\\\frac{d_x d_y}{4} e_{12}\\\\\\\\\r\n                    & R p \\\\widetilde{R} = \\\\frac{x}{1 + d_x x + d_y y} e_{31} + \\\\frac{y}{1 + d_x x + d_y y} e_{23} + 1 e_{12}\r\n                    \\\\end{aligned}`}\r\n\r\n                    Interestingly the composed rotor picks up the {`$e_{12}$`} part for which we already showed that it is the identity map.\r\n                    In different notation, the composed map is\r\n\r\n                    {`\\\\begin{aligned}\r\n                    (x, y) \\\\to (\\\\frac{x}{1 + d_x x + d_y y}, \\\\frac{y}{1 + d_x x + d_y y})\r\n                    \\\\end{aligned}`}\r\n\r\n                    Perhaps it is possible to construct scaling rotors for each direction this way if we could \r\n                    change the $x$ and $y$ in the denominator by adjusting our up function and basis vectors.\r\n                </div>\r\n            </div>\r\n            <h5>Non-isotropic scaling rotor</h5>\r\n            <div>\r\n                We want rotors that only scale in one direction, instead of scaling all directions equally. \r\n                Start with PGA, but for up instead use the logarithm on the coordinates\r\n\r\n                {`\\\\begin{aligned}\r\n                up(x, y) = log(x) e_1^* + log(y) e_2^* + 1 e_0^*\r\n                \\\\end{aligned}`}\r\n\r\n                If we try to find the inverse mapping (ie. get the $(x, y)$ coordinates a bivector represents) we have \r\n\r\n                {`\\\\begin{aligned}\r\n                x = exp(\\\\frac{\\\\langle p \\\\rangle_{1^*}}{\\\\langle p \\\\rangle_{0^*}}), y = exp(\\\\frac{\\\\langle p \\\\rangle_{2^*}}{\\\\langle p \\\\rangle_{0^*}})\r\n                \\\\end{aligned}`}\r\n\r\n                If we now apply a translator $T_x(log(s_x))$ that translates by $log(s_x)$ in the $e_x^*$ direction (just like in the usual PGA), we get \r\n\r\n                {`\\\\begin{aligned}\r\n                & T_x(log(s_x)) up(x, y) \\\\widetilde{T_x}(log(s_x)) \\\\\\\\\r\n                = & (log(x) + log(s_x)) e_x^* + log(y) e_y^* + 1 e_0^* \\\\\\\\\r\n                = & log(x s_x) e_x^* + log(y) e_y^* + 1 e_0^*\r\n                \\\\end{aligned}`}\r\n\r\n                Recovering the $(x', y')$ coordinates this result represents using the inverse up mapping we get \r\n\r\n                {`\\\\begin{aligned}\r\n                x' & = exp(\\\\frac{log(x s_x)}{1}) = x s_x \\\\\\\\\r\n                y' & = exp(\\\\frac{log(y)}{1}) = y\r\n                \\\\end{aligned}`}\r\n\r\n                And we have non-isotropic scaling, yay! Of course the same will work for scaling $y$ too. \r\n                There is still a big issue though: $x$ and $y$ have to be greater than zero since the logarithm \r\n                is not defined otherwise (or we could just use the complex logarithm? although maybe there's a nicer GA way \r\n                of avoiding arbitrary complex numbers here).\r\n\r\n                <CoffeeShop id=\"dg4qW2Vqs\" title=\"Non-isotropic scaling with rotors\" />\r\n            </div>\r\n            <h5>Translators in any variable for polynomial up functions</h5>\r\n            <b style={{color: \"red\"}}>This part is flawed / wrong, but I left it up since it still contains some useful ideas.</b>\r\n            <div>\r\n                Assume we have an up function $up(x, ...) = x e_1^* + x^2 e_2^* + 1 e_0^* + ...$ which can represent parabolas, lines, points and so on.\r\n                If we want to have translation as rotors (translators), it's not that easy. In PGA we only have one basis vector with an $x$ coefficient \r\n                so we can do the translation using a single rotor {`$e^{\\\\frac{d}{2} e_{x0}}$`}, but if we did with the above up function we would change \r\n                the $x$ coefficient while leaving the $x^2$ coefficient untouched. If we look at the OPNS / VPNS of a point that was only translated in $e_1^*$ \r\n\r\n                {`\\\\begin{aligned}\r\n                & (x e_1^* + x^2 e_2^* + 1 e_0^*) \\\\vee ((a + d) e_1^* + b e_2* + c e_0*) \\\\\\\\\r\n                = & x b e_{12}^* + x c e_{10}^* + x^2 (a + d) e_{21}^* + x^2 c e_{20}* + (a + d) e_{01}* + b e_{02}* \\\\\\\\\r\n                = & (x c - a - d) e_{10}^* + (x b - a - d) e_{12}^* + (x^2 c - b) e_{20}^* = 0\r\n                \\\\end{aligned}`}\r\n\r\n                we get three equations that have to vanish\r\n\r\n                {`\\\\begin{aligned}\r\n                x c - a - d & = 0 \\\\\\\\\r\n                x b - a - d & = 0 \\\\\\\\\r\n                x^2 c - b & = 0 \\\\\\\\\r\n                \\\\end{aligned}`}\r\n\r\n                Notice the first and second equation together give $x b = x c$. But the third equation gives $b = x^2 c$. \r\n                Both of these together give $x^3 c = x c$ which can only be true for $x = 0$. and our wrongly translated point does indeed not \r\n                represent anything useful.\r\n            </div>\r\n            <div>\r\n                To get something useful again we need to translate all coefficients where $x$ appears in the up function. For instance $x^2$ should get translated as\r\n                \r\n                {`\\\\begin{equation}\r\n                x^2 \\\\to (x + d)^2 = x^2 + d^2 + 2 d x\r\n                \\\\end{equation}`}\r\n                \r\n                First we need to translate the $e_2^*$ coefficient by $d^2$ which is easy using the rotor {`$e^{\\\\frac{d^2}{2} e_{20}}$`}. \r\n                Next we need to translate the $e_2^*$ part by $2 d x$ which is a shear. \r\n                This is not possible with the current set of basis vectors we have available as we can only translate by constants and not in proportion to $x$ as required here.\r\n            </div>\r\n            <div>\r\n                We introduce a new basis vector $e_3^2 = 0$ with coefficient $x$ in the up function. Then we get the rotors we need as {`$e^{d e_{13}}$`} (note, no division by 2 as we need twice \r\n                the amount). This solves the issue of translating the $x^2$ part. However this introduces a new problem. The new basis vector we introduced has coefficient $x$ so in order \r\n                to keep it consistent (non-empty OPNS / VPNS) we need to translate it too. \r\n            </div>\r\n            <div>\r\n                Again this is not that easy because usually we use the bivectors containing $e_0$ to do translations. We can't do that here to translate $e_3$ because it squares to zero and thus \r\n                the bivector {`$e_{30}$`} will result in zero when multiplied with {`$e_0^* = e_{123}$`} which is the part that usually enables us to do translation for non-zero squaring basis vectors.\r\n            </div>\r\n            <div>\r\n                <b style={{color: \"red\"}}>The idea in this step is wrong which makes the entire thing not work out. The bivector will give a shearor not a translator, and will also affect the wrong dual basis vector.</b>\r\n                We introduce a new basis vector $e_4^2 = 1$ with coefficient $1$ in the up function. This will allow us to do translations in $e_3^*$ with the bivector {`$e_{34}$`} \r\n                because it squares to zero (ie. does translation) and {`$e_{34} e_4^* = e_{34} e_{0123} = -e_{0124}$`} instead of zero.\r\n            </div>\r\n            <div>\r\n                Now we can compose all the rotors we just came up with to get a single rotor that does translation in $x$ by $d$. In conclusion, we introduced two new basis vectors, one for \r\n                allowing us to do translation in proportional to $x$ and another to allow us to translate the new basis vector by a constant. The composed rotor is a lot more complicated too. \r\n                However this will work for any polynomial if we apply this idea recursively. For example for $x^3$ we want $(x + d)^3 = x^3 + d^3 + 3 d^2 x + 3 d x^2$. Here we could do the same thing:\r\n                \r\n                <ol>\r\n                    <li>Translate $x^3$ part by $d^3$</li>\r\n                    <li>Introduce new basis vector with coeff. $x$ for translation by $d x$</li>\r\n                    <li>Introduce new basis vector for translating the new basis vector by $d$</li>\r\n                    <li>Introduce new basis vector for translation relative to $x^2$</li>\r\n                    <li>New basis vector needs to be translated as $(x + d)^2$ so we can apply the same idea</li>\r\n                    <li>...</li>\r\n                    <li>Tears, lots of new basis vectors, complicated rotors, but it works out</li>\r\n                </ol>\r\n\r\n                Finally here's an example of this in action, however the renderer doesn't seem to like this very much as the points don't get rendered correctly (or I made a mistake somewhere?) but you get the idea hopefully.\r\n\r\n                <CoffeeShop id=\"OoWAStmiP\" />\r\n\r\n                Perhaps there's a better way. I don't know whether this works for functions other than polynomials either, it might for some, but it certainly doesn't for many because the correction terms \r\n                can not be done with translators, although if we had more rotors in our toolbox than just translators this might be fixable.\r\n            </div>\r\n            <h4><Link to=\"/ga-design-interpolating-points\">Next: Design of Geometric Algebras - Interpolating Points</Link></h4>\r\n        </div >\r\n    )\r\n}","import React from \"react\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\nimport { CoffeeShop } from \"./CoffeeShop\"\r\n\r\nexport function GADesignInterpolatingPoints() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Designing Geometric Algebras - Interpolating Points</h3>\r\n            <div>\r\n                Now for an application that makes use of the fact that we can represent arbitrary shapes as GA objects.\r\n                Let's start with a concrete example. We have three points which are also shown in the figure below. We want to find $y$ values for other values of $x$ between our three points.\r\n                This is called interpolation for $x$ between our known points, and extrapolation for $x$ outside of our known points. In other words, we want to find a curve that reasonably interpolates our points.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                (x_1, y_1) & = (-3, 2) \\\\\\\\\r\n                (x_2, y_2) & = (0, 3) \\\\\\\\\r\n                (x_3, y_3) & = (1, 1)\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <ImageWithSub src=\"/images/polynomial-interpolation-points.svg\" width=\"100%\" text=\"Figure 1 - Blue: Points we want to interpolate.\" />\r\n            <div>\r\n                A natural choice for a family of curves are polynomials in $x$, so we will focus on them for now but the procedure outlined in this article will work for any other\r\n                family of curves too. It turns out that $N$ points unique determine the coefficients of a degree $N-1$ polynomial.\r\n                For our example, $y = c_0 + c_1 x + c_2 x^2$ is of degree two so its coefficients can be found given three points. The solution we want to find is shown below.\r\n            </div>\r\n            <ImageWithSub src=\"/images/polynomial-interpolation-solution.svg\" width=\"100%\" text=\"Figure 2 - Blue: Points we want to interpolate. Green: Second degree polynomial interpolating the points.\" />\r\n            <h5>Representing polynomials in Geometric Algebra</h5>\r\n            <div>\r\n                In the first section we learnt that we can represent polynomials in Geometric Algebra by introducing a basis vector for each term of it, including the $y$ term.\r\n                For our concrete example we would have four basis vectors corresponding to $1, x, x^2, y$ and the up function which maps $(x, y)$ points to vectors in the 4D space is\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    up(x, y) = 1 e_0 + x e_1 + x^2 e_2 + y e_3\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Finding the interpolating object</h5>\r\n            <div>\r\n                Now we can represent points. How do we get an object representing a curve that goes through all points?\r\n                We know we can join points together to make shapes which go through all of them with the wedge product.\r\n                In general we have the following equation which results in the pseudovector $p$:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    p = \\\\bigwedge_{n=1}^{N} up(x_n, y_n) = \\\\sum_{n=0}^{N-1} p_n e_n^*\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Where $N$ is the number of points. This should give us some object representing a shape that goes through all of the points that were joined.\r\n            </div>\r\n            <h5>Getting the interpolating polynomial coefficients from the object</h5>\r\n            <div>\r\n                We can examine this object by applying the Outer Product Null Space / Join Null Space equation:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                    p \\\\wedge up(x, y) & = (p_0 e_0^* + p_1 e_1^* + p_2 e_2^* + p_3 e_3^*) \\\\wedge (1 e_0 + x e_1 + x^2 e_2 + y e_3) = \\\\\\\\\r\n                    & = e_{0123} (p_0 + p_1 x + p_2 x^2 + p_3 y) = 0\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                To bring it into the usual form we still need to bring $y$ on the other side with a coefficient of $1$. We can also get rid of the pseudoscalar {`$e_{1234}$`}. This results in\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    y =  -\\\\frac{p_0}{p_3} - \\\\frac{p_1}{p_3} x - \\\\frac{p_2}{p_3} x^2\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                So indeed our object represents a polynomial. In general, to get the ordinary coefficients $c_n$ from $p$ we have\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                c_n = -\\\\frac{p_n}{p_{N}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We can see that the coefficients of the polynomial can be directly read off of $p$'s coefficients. This is all that we needed. We wedged together some points\r\n                into a pseudovector, we know that the object goes through all of our points, and from the pseudovector's coefficients we can easily get the interpolating polynomial's coefficients.\r\n            </div>\r\n            <div>\r\n                For our concrete example we have the following pseudovector for representing the polynomial\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    p = up(-3, 2) \\\\wedge up(0, 3) \\\\wedge up(1, 1) = 36 e_0^* - 17 e_1^* - 7 e_2^* - 12 e_3^*\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Reading off the coefficients and dividing by $y$'s coefficient yields the interpolating polynomial equation\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    y = -\\\\frac{36}{-12} - \\\\frac{-17}{-12} x - \\\\frac{-7}{-12} x^2 = 3 - \\\\frac{17}{12} x - \\\\frac{7}{12} x^2\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                which corresponds exactly to the green curve in the figure 2.\r\n            </div>\r\n            <h4>Algorithm Summary</h4>\r\n            <div>\r\n                To summarize the procedure, given N points $(x_n, y_n)$\r\n            </div>\r\n            <ol>\r\n                <li>We want to interpolate with a polynomial of degree $N-1$ with coefficients $c_n$: {`$y = \\\\sum_{n=0}^{N - 1} c_n x^n$`}</li>\r\n                <li>Use GA with N basis vectors and up function: {`$up(x, y) = y e_{N-1} + \\\\sum_{n=0}^{N - 2} x^n e_n$`}</li>\r\n                <li>Build polynomial object $p$ by wedging together N up projected points: {`$p = \\\\bigwedge_{n=1}^{N} up(x_n, y_n)$`}</li>\r\n                <li>Extract interpolating polynomial coefficients $c_n$ from $p$: {`$c_n = -\\\\frac{p_n}{p_N}$`}</li>\r\n            </ol>\r\n            <h4>Bonus: Different basis functions</h4>\r\n            <div>\r\n                While we were focusing on polynomials here, this process works identically with other functions too, as no assumptions about the basis functions were made.\r\n                The only change is to use a different up function in step 1. Below I tried some different basis functions for three points and five points.\r\n            </div>\r\n\r\n            <h5>Three points</h5>\r\n            <h5>$up(x, y) = e_0 + x e_1 + x^2 e_2 + y e_3$</h5>\r\n            <CoffeeShop id=\"VQQexSqJn\" />\r\n\r\n            <h5>$up(x, y) = e_0 + sin(x) e_1 + cos(x) e_2 + y e_3$</h5>\r\n            <CoffeeShop id=\"sE0Jz4iEG\" />\r\n\r\n            <h5>$up(x, y) = e_0 + sin(x) e_1 + sin(2x) e_2 + y e_3$</h5>\r\n            <CoffeeShop id=\"qsxCQ1Ker\" />\r\n\r\n            <h5>$up(x, y) = e_0 + 2^x e_1 + 3^x e_2 + y e_3$</h5>\r\n            <CoffeeShop id=\"y8rGJl9mO\" />\r\n\r\n            <h5>Five points</h5>\r\n            <h5>$up(x, y) = e_0 + x e_1 + x^2 e_2 + + x^3 e_3 + x^4 e_4 + y e_5$</h5>\r\n            <CoffeeShop id=\"9j6q1TBbk\" />\r\n\r\n            <h5>$up(x, y) = e_0 + sin(x) e_1 + cos(x) e_2 + + sin(2x) e_3 + cos(2x) e_4 + y e_5$</h5>\r\n            <CoffeeShop id=\"tGzSdmU6L\" />\r\n\r\n            <h5>$up(x, y) = e_0 + sin(x) e_1 + sin(2x) e_2 + + sin(3x) e_3 + sin(4x) e_4 + y e_5$</h5>\r\n            <CoffeeShop id=\"gGQJmaHTe\" />\r\n\r\n            <h5>$up(x, y) = e_0 + 2^x e_1 + 3^x e_2 + + 4^x e_3 + 5^x e_4 + y e_5$</h5>\r\n            <CoffeeShop id=\"JguozIFuo\" />\r\n\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We started by looking at what interpolation is and we chose to use polynomials for interpolation. We then applied our knowledge from the\r\n                previous section to represent polynomials in Geometric Algebra. With the wedge product we constructed an object representing the interpolating\r\n                polynomial from which we could just read off the coefficients.\r\n            </div>\r\n            <div>\r\n                This process generalizes to any number of points and it uses only very simple GA operations, so it might be preferable over the usual methods like\r\n                using matrices or Lagrange polynomials. It also works with any basis functions, not just polynomials.\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\n\r\nexport function SRIntro() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Introduction</h3>\r\n            <h4>What is Special Relativity?</h4>\r\n            <div>\r\n                Special Relativity published by Albert Einstein in 1905 makes clearer the relation between time and space in physics.\r\n                It does this by unifying them and introducing two postulates:\r\n            </div>\r\n            <h5>Postulate 1</h5>\r\n            <code>\r\n                The laws of physics are the same in all inertial reference frames.\r\n            </code>\r\n            <div>\r\n                An inertial reference frame is the frame of an unaccelerated observer, ie. one moving with constant velocity.\r\n                The postulate says that for such frames, we can write down formulas which will be true for all observers\r\n                even if their velocity is different. The more general case with accelerated reference frames is treated in Einstein's General Relativity.\r\n            </div>\r\n            <h5>Postulate 2</h5>\r\n            <code>\r\n                The speed of light (in vacuum) is the same for all observers.\r\n            </code>\r\n            <div>\r\n                Meaning, no matter the motion of the observer, light will always move at the speed of light.\r\n            </div>\r\n            <div>\r\n                These postulates might seem trivial for now (everybody knows that light always moves at the speed of light right?), but we will see that\r\n                that they have huge consequences. If you are already familiar with Special Relativity, you will probably also see that the treatment\r\n                with Geometric Algebra simplifies a lot of things.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-einstein.png\" text=\"Albert Einstein and some formulas derived from the postulates of Special Relativity\" width=\"70%\" />\r\n            <h4>Why Special Relativity?</h4>\r\n            <div>\r\n                Without Special Relativity, we will see that addition of velocities breaks down at speeds close to the speed of light.\r\n                We will also notice many interesting phenomena such as electric fields being seen as magnetic fields by observers moving at high speeds\r\n                relative to them, shedding light on the duality between the two. Furthermore it provides a pathway for\r\n                understanding <a href=\"https://en.wikipedia.org/wiki/General_relativity\">General Relativity</a> which is the basis for our best models of gravity.\r\n            </div>\r\n            <h4>References</h4>\r\n            <h5>Geometric Algebra</h5>\r\n            <div>\r\n                This series assumes you already know the basics of Geometric Algebra and rotors. There are a couple of articles about that on this website but there are also fantastic\r\n                introductions on YouTube:\r\n                <ul>\r\n                    <li><a href=\"https://youtu.be/60z_hpEAtD8\">A Swift Introduction to Geometric Algebra</a> by Sudgy who is also working on a complete Geometric Algebra series</li>\r\n                    <li><a href=\"https://www.youtube.com/watch?v=PNlgMPzj-7Q&amp;list=PLpzmRsG7u_gqaTo_vEseQ7U8KFvtiJY4K\">Geometric Algebra playlist</a> by Mathoma</li>\r\n                    <li><a href=\"https://youtu.be/Idlv83CxP-8\">Let's remove Quaternions from every 3D Engine: Intro to Rotors from Geometric Algebra</a> by Marc ten Bosch (with <a href=\"https://marctenbosch.com/quaternions/\">accompanying article</a>)</li>\r\n                    <li>Various videos on the <a href=\"https://www.youtube.com/user/EnkiOrigami\">Bivector channel</a></li>\r\n                </ul>\r\n            </div>\r\n            <div>\r\n                There are also various books that cater to different audiences, to name a few:\r\n                <ul>\r\n                    <li><a href=\"https://geometricalgebra.org/\">Geometric Algebra for Computer Science</a> by Leo Dorst</li>\r\n                    <li><a href=\"https://www.cambridge.org/core/books/geometric-algebra-for-physicists/FB8D3ACB76AB3AB10BA7F27505925091\">Geometric Algebra for Physicists</a> by Anthony Lasenby and Chris Doran: Mostly assumes knowledge of physics in the ordinary formalism and introduces them with GA, covers a lot of topics and even General Relativity. I used this book a lot to learn about Special Relativity (and other topics).</li>\r\n                    <li><a href=\"http://peeterjoot.com/writing/geometric-algebra-for-electrical-engineers/\">Geometric Algebra for Electrical Engineers</a> by Peeter Joot: What I like about this one is that it does not contain much \"noise\", just straight usefulness</li>\r\n                    <li><a href=\"http://www.faculty.luther.edu/~macdonal/laga/index.html\">Linear and Geometric Algebra</a> by Alan Macdonald</li>\r\n                </ul>\r\n            </div>\r\n            <div>\r\n                The website <a href=\"https://bivector.net/\">bivector.net</a> also contains links to more resources as well as our community discord. Feel free to join and ask questions!\r\n            </div>\r\n            <h5>Special Relativity</h5>\r\n            <div>\r\n                There are many excellent videos on YouTube about Special Relativity, for example <a href=\"https://www.youtube.com/watch?v=FdWMM6aXpYE\">The Science Asylum's video</a> great.\r\n                Leonard Susskind has a recorded lecture series about Special Relativity <a href=\"https://www.youtube.com/watch?v=toGH5BdgRZ4&amp;list=PLD9DDFBDC338226CA\">here</a>. His lectures are always amazing.\r\n                For books I can only recommend \"Geometric Algebra for Physicists\" mentioned above. I haven't looked into any specific non-GA books about Special Relativity.\r\n            </div>\r\n            <h4><Link to=\"/sr-ga-review\">Special Relativity with Geometric Algebra - Geometric Algebra Review</Link></h4>\r\n        </div >\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\n\r\n\r\nexport function SRGAReview() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Geometric Algebra Review</h3>\r\n            <h4>Ordinary 3D Geometric Algebra</h4>\r\n            <div>\r\n                Let's review a couple of properties of ordinary 3D Geometric Algebra. If you are not yet familiar with it there are a few excellent\r\n                videos on YouTube as well as a couple of books going into GA in more detail. A few were mentioned in the previous section.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-ordinary-ga.png\" text=\"Figure 1 - Blue: Orthonormal basis vectors. Red: Position vectors $a, b$. Yellow: difference vector $v$ from $a$ to $b$.\" width=\"50%\" />\r\n            <div>\r\n                We have three <u style={{ textDecorationColor: \"#3721FF\", textDecorationThickness: 3 }}>orthonormal basis vectors $e_x, e_y, e_z$</u>. Written using the <a href=\"https://en.wikipedia.org/wiki/Kronecker_delta\">Kronecker delta</a> we have {`$e_i \\\\cdot e_j = \\\\delta^i_j$`},\r\n                which says that the inner product of two same basis vectors is $1$, and the inner product of two different basis vectors is $0$. For example we have $e_x \\cdot e_x = 1$ and $e_x \\cdot e_y = 0$.\r\n            </div>\r\n            <div>\r\n                The <u style={{ textDecorationColor: \"#FF4760\", textDecorationThickness: 3 }}>position vectors $a$ and $b$</u> from figure 1 can be written terms of the basis vectors as follows\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                    a & = a_x e_x + a_y e_y \\\\\\\\\r\n                    b & = b_x e_x + b_y e_y\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We can form the <u style={{ textDecorationColor: \"#FFD900\", textDecorationThickness: 3 }}>difference vector $v$</u> from $a$ to $b$ by subtracting $a$ from $b$ to get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    v = b - a = (b_x - a_x) e_x + (b_y - a_y) e_y = \\\\Delta x e_x + \\\\Delta y e_y\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                To get the length squared $||v||^2$ we have to square $v$, which yields the same result as the Pythagorean theorem\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    ||v||^2 = v^2 = (\\\\Delta x e_x + \\\\Delta y e_y)^2 = \\\\Delta x^2 + \\\\Delta y^2\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h4>Active and Passive Transformations</h4>\r\n            <div>\r\n                You might not have heard the terms <a href=\"https://en.wikipedia.org/wiki/Active_and_passive_transformation\">active and passive transformations</a> before,\r\n                but it is often a useful distinction to make. We will review these two types of transformations now too.\r\n            </div>\r\n            <h5>Active Transformations</h5>\r\n            <ImageWithSub src=\"/images/sr-active-transformation.png\" text=\"Figure 2 - Blue: Orthonormal basis vectors. Yellow: Original vector. Teal: Active transformation rotor. Purple: Original vector transformed using rotor.\" width=\"50%\" />\r\n            <div>\r\n                Active transformations change objects. The active transformations we are interested in here are those with rotors.\r\n                In ordinary 3D GA we have three basis blades {`$e_{xy}, e_{yz}, e_{xz}$`} which can be used to rotate in the planes denoted by their subscripts.\r\n                For example, as in figure 2, a <u style={{ textDecorationColor: \"#00FFFF\", textDecorationThickness: 3 }}>rotor</u> that rotates by an angle $\\varphi$ in the XY plane is formed like this\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    R_{xy} = e^{-\\\\frac{\\\\varphi}{2} e_{xy}} = cos(-\\\\frac{\\\\varphi}{2}) + sin(-\\\\frac{\\\\varphi}{2}) e_{xy}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The rotor is then applied to an object, such as our <u style={{ textDecorationColor: \"#FFD900\", textDecorationThickness: 3 }}>vector $v$</u>, with a two-sided product often called the sandwich product\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    v' = R_{xy} v \\\\widetilde{R}_{xy}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The <u style={{ textDecorationColor: \"#B200FE\", textDecorationThickness: 3 }}>resulting vector $v'$</u> will in general be different from $v$, so this is an active transformation as the object did actually change.\r\n            </div>\r\n            <div>\r\n                Rotating a vector does not change its length (verify this as an excercise if you wish by squaring the rotated vector), so applying rotors preserves distances.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    ||v'||^2 = ||R_{xy} v \\\\widetilde{R}_{xy}||^2 = v_x'^2 + v_y'^2 = v_x^2 + v_y^2 = ||v||^2\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Passive Transformations</h5>\r\n            <ImageWithSub src=\"/images/sr-passive-transformation-before.png\" text=\"Figure 3 - Coordinate system using original orthonormal basis vectors. Blue: Original orthonormal basis vectors. Yellow: Passive transformation rotor. Green: Original orthonormal basis vectors transformed with rotor. Teal: Vector.\" width=\"50%\" />\r\n            <div>\r\n                Passive transformations act on the coordinate basis vectors. They do not actually change the objects, only the perspective on them.\r\n                They are also called change of basis. We are interested in passive transformations performed by rotors.\r\n            </div>\r\n            <div>\r\n                Let's say our first set of <u style={{ textDecorationColor: \"#0026FF\", textDecorationThickness: 3 }}>basis vectors $e_x, e_y$</u> belonged to one person. We have another person\r\n                with <u style={{ textDecorationColor: \"#00FF22\", textDecorationThickness: 3 }}>basis vectors $e_x', e_y'$</u> who is looking in another direction from the first person such as in figure 3.\r\n                The rotation between the first and second set of basis vectors can be performed by a <u style={{ textDecorationColor: \"#FFD900\", textDecorationThickness: 3 }}>rotor $R$</u>\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                    e_x' & = R e_x \\\\widetilde{R} \\\\\\\\\r\n                    e_y' & = R e_y \\\\widetilde{R}\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-passive-transformation-after.png\" text=\"Figure 4 - Coordinate system using transformed orthonormal basis vectors. Blue: Original orthonormal basis vectors. Yellow: Passive transformation rotor. Green: Original orthonormal basis vectors transformed with rotor. Teal: Vector.\" width=\"50%\" />\r\n            <div>\r\n                We can now see how the second person views the world by drawing the coordinate system using their basis vectors. The <u style={{ textDecorationColor: \"#00F1F1\", textDecorationThickness: 3 }}>vector $v$</u> <i>appears</i> to rotate  in the opposite\r\n                direction. It is very important to note though that the vector does not actually change. It is merely viwed in a different basis but it is fundamentally the same vector. The vector $v$ expressed in the old and the new basis is\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    v = v_x e_x + v_y e_y = v_x' e_x' + v_y' e_y'\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                As the vector did not actually change, its length when expressed in the new basis is still be the same as before too.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    ||v||^2 = (v_x' e_x' + v_y' e_y')^2 = v_x'^2 + v_y'^2 = v_x^2 + v_y^2\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Another important property of passive transformations with rotors is that they keep the basis vectors orthonormal.\r\n            </div>\r\n            <div>\r\n                Important note: In this series we will only be dealing with orthonormal bases to simplify things. This excludes coordinate system such as spherical coordinates.\r\n                In order to deal with more general bases a concept called reciprocal frames is required. Overall this is not a big change to make however, and it would be easy to adjust\r\n                all our upcoming results to use them.\r\n            </div>\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We shortly reviewed position and difference vectors. We looked at active transformations which change objects, in particular active transformations with rotors\r\n                which perserve lengths. We also looked at passive transformations which only affect coordinate basis vectors but do not actually affect any objects. For these\r\n                we also noticed that the length of vectors can obtained using the coefficients of the vector in the transformed basis. Furthermore passive transformations with\r\n                rotors keep orthonormal bases orthonormal.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Orthonormal basis for ordinary GA: {`$e_i \\\\cdot e_j = \\\\delta^i_j$`}</li>\r\n                    <li>Vector expressed in basis: {`$v = v_x e_x + v_y e_y$`}</li>\r\n                    <li>Vector length squared: {`$||v||^2 = v^2 = v_x^2 + v_y^2$`} </li>\r\n                    <li>Active transformation with rotor: {`$v' = R v \\\\widetilde{R}, ||v'||^2 = ||v||^2$`} </li>\r\n                    <li>Passive transformation with rotor: {`$e_i' = R e_i \\\\widetilde{R}, e_i \\\\cdot e_j = \\\\delta^i_j \\\\iff e_i' \\\\cdot e_j' = \\\\delta^i_j$`} </li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Next we will look at how we can describe Spacetime with Geometric Algebra motivated by a thought experiment.\r\n            </div>\r\n            <h4><Link to=\"/sr-spacetime-algebra\">Special Relativity with Geometric Algebra - Spacetime Algebra</Link></h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\n\r\n\r\nexport function SRSpacetimeAlgebra() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Spacetime Algebra</h3>\r\n            <h4>Paths of objects</h4>\r\n            <div>\r\n                There are different ways to understand and formalize the paths objects take and how they move over time.\r\n            </div>\r\n            <h5>Position over time</h5>\r\n            <ImageWithSub src=\"/images/sr-path-basic.png\" text=\"Figure 1 - Path of an object with constant velocity. X-axis: time. Y-axis: space.\" width=\"50%\" />\r\n            <div>\r\n                In physics we often draw the path an object takes over time in a diagram where time is on the x-axis and space is on the y-axis.\r\n                Figure 1 shows such a diagram. For an object with a constant velocity of one half meters per second we have the following equations\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                    s(t) & = \\\\frac{1}{2} \\\\mathrm{\\\\frac{m}{s}} t \\\\\\\\\r\n                    v(t) & = \\\\frac{\\\\partial}{\\\\partial t} s(t) = \\\\frac{1}{2} \\\\mathrm{\\\\frac{m}{s}}\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Position over time - flipped space and time axes</h5>\r\n            <div>\r\n                In relativity, the space and time axes are usually flipped, so we space is on the x-axis and time is on the y-axis.\r\n                We will also follow this standard practice. Doing this our diagram will look like this\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-path-flipped.png\" text=\"Figure 2 - Path of an object with constant velocity,  X-axis: space. Y-axis: time.\" width=\"50%\" />\r\n            <div>\r\n                Since we are using geometric algebra, we will use vectors to formulate paths of objects instead. We will have the usual spatial basis vectors $e_x, e_y, e_z$, but why\r\n                not introduce a basis vector $e_t$ for time too? After all, in our diagram these don't really look any different. If we do this we have four basis vectors in total\r\n                and instead of just space we now have spacetime.\r\n            </div>\r\n            <h5>Parameterized paths with vectors</h5>\r\n            <ImageWithSub src=\"/images/sr-path-vector.png\" text=\"Figure 3 - Light-blue: Orthonormal basis vectors for time and space. Blue: Vector path of an object parameterized by $\\lambda$. Green: Path velocity of the blue path.\" width=\"60%\" />\r\n            <div>\r\n                For our previous example, for every step in the space direction we take two steps in the time direction. So an unnormalized direction vector for the <u style={{ textDecorationColor: \"blue\", textDecorationThickness: 3 }}>path</u> is given by $2 e_t + 1 e_x$.\r\n                We can now introduce a parameter $\\lambda$ that sweeps out our path\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    s(\\\\lambda) = \\\\lambda (2 e_t + 1 e_x) \\\\\\\\\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We can also calculate a <u style={{ textDecorationColor: \"#00FF91\", textDecorationThickness: 3 }}>path velocity</u> by taking the derivative with respect to our path parameter $\\lambda$\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    v = \\\\frac{\\\\partial}{\\\\partial \\\\lambda} s(\\\\lambda) = 2 e_t + 1 e_x\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The path velocity is always tangent to the path.\r\n            </div>\r\n            <div>\r\n                Note that the parameterization for our path is somewhat arbitrary. We could just as well have multiplied by path by a constant and have gotten the same path.\r\n                What happens to the path velocity when we multiply our path by a constant factor $k$?\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                    s_k(\\\\lambda) & = \\\\lambda k (2 e_t + 1 e_x) \\\\\\\\\r\n                    v_k & = \\\\frac{\\\\partial}{\\\\partial \\\\lambda} s_k(\\\\lambda) = k (2 e_t + 1 e_x)\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The path velocity also receives the constant factor $k$. In order to fix this arbitrary path parameter, we choose the\r\n                length of the path velocity to be the speed of light, ie. $||v||^2 = v^2 = c^2$. The path parameter which we generally called $\\lambda$\r\n                is then called the proper time $\\tau$.\r\n            </div>\r\n            <div>\r\n                Our path parameterized by proper time is then $s(\\tau)$ and we introduce a short-hand notation for the derivative with respect to proper time {`$\\\\dot{s}(\\\\tau) = \\\\frac{\\\\partial}{\\\\partial \\\\tau} s(\\\\tau)$`}.\r\n                Because of our definition for proper time we now have {`$\\\\dot{s}^2 = c^2$`}. In many places the same equation but with $1$ on the right-hand side is seen.\r\n                This is because often the choice $c = 1$ is made.\r\n            </div>\r\n\r\n            <h4>Spacetime events</h4>\r\n            <div>\r\n                Another thing we want to look at is what the points in our spacetime, such as the points on our paths, represent. A point contains a time coordinate and three space coordinates.\r\n                Points in spacetime are also called events because of this.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-time-coordinate.png\" text=\"Figure 4 - Time as another dimension and spacetime events\" width=\"50%\" />\r\n            <div>\r\n                An event $a$ as shown in the diagram could be \"I left home at 8am\" with the position being <b>home</b> and the time being <b>8am</b>.\r\n                Another event $b$ could then be \"I arrived at work at 9am\" with position <b>work</b> and time <b>9am</b>. We can now form difference vectors again.\r\n                For this example assume home and work are <b>10km</b> apart in the x direction. Then we have a difference vector\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`$v = 3600 \\\\mathrm{s} e_t + 10 \\\\mathrm{km} e_x$`}\r\n            </div>\r\n            <div>\r\n                Does this expression make sense? The first problem we can notice is that the units don't match up. How do we add kilometers (spatial distance) and seconds (time difference)?\r\n                To remedy this, we could multiply the time component by a constant speed as that would result in a distance. Why not choose the speed of light $c$? We now the following\r\n                expression with the correct units\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`$v = c 3600 \\\\mathrm{s} e_t + 10 \\\\mathrm{km} e_x$`}\r\n            </div>\r\n            <div>\r\n                Well we got around the unit issue, although we did not justify the multiplication by $c$ very well yet. The true justification for it will come soon.\r\n            </div>\r\n\r\n            <h4>More spacetime paths</h4>\r\n            <div>\r\n                Let's take a look at some more types of paths in spacetime.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-paths.png\" text=\"Figure 5 - Paths in spacetime. Blue (a): Object at rest. Green (b): Object with constant velocity. Purple (c): Accelerated object. Yellow (l): Light. Red (e): Path faster than light.\" />\r\n            <h5><u style={{ textDecorationColor: \"blue\", textDecorationThickness: 3 }}>Object at rest (a)</u></h5>\r\n            <div>\r\n                An object at rest does not move in space over time. Its path points purely in the time direction.\r\n                The path can of course still be arbitrarily offset on the space axes.\r\n            </div>\r\n            <div>\r\n                The path velocity always points in the $e_t$ direction, so objects at rest will always have path velocity proportional to $e_t$.\r\n                Paths parameterized by proper time $\\tau$ will have path velocity $c e_t$ because by definition, the path velocity for paths parameterized by proper time squares to $c^2$.\r\n                This will become very important later as objects at rest play an important role in Special Relativity.\r\n            </div>\r\n            <h5><u style={{ textDecorationColor: \"lime\", textDecorationThickness: 3 }}>Object with constant velocity (b)</u></h5>\r\n            <div>\r\n                Objects with constant velocity can move in space. Their path will be a rotated straight line. The more rotated the line is towards the space dimension, the faster the object goes.\r\n            </div>\r\n            <div>\r\n                The path velocity for an object moving along the x-direction will be some mix of $e_x$ and $e_t$, although there are some restrictions to this.\r\n            </div>\r\n            <h5><u style={{ textDecorationColor: \"purple\", textDecorationThickness: 3 }}>Object with acceleration (c)</u></h5>\r\n            <div>\r\n                An object with acceleration could trace out a curved path like $c$ in the diagram. Objects with non-zero acceleration won't be covered for now.\r\n            </div>\r\n            <h5><u style={{ textDecorationColor: \"gold\", textDecorationThickness: 3 }}>Light (l)</u></h5>\r\n            <div>\r\n                Light always moves at the speed of light. This is the second postulate of Special Relativity. Its path can be parameterized by $l(\\lambda) = c \\lambda e_t + c \\lambda e_x$\r\n                (the factor of $c$ for the time dimension, as mentioned earlier, will be fully justified soon).\r\n                This will trace out a 45° angle in our diagrams.\r\n            </div>\r\n            <h5><u style={{ textDecorationColor: \"red\", textDecorationThickness: 3 }}>Faster than light (e)</u></h5>\r\n            <div>\r\n                Because nothing can move faster than light, this means all of our paths need to be steeper than 45°.\r\n                Otherwise the object would be going faster than light.\r\n            </div>\r\n\r\n            <h4>Spacetime distance</h4>\r\n            <div>\r\n                Something we have not looked at yet is what a good notion of distance in spacetime is. Squaring vectors gives us vector lengths.\r\n                When we do this, we make use of the squares of basis vectors. What should our spacetime basis vectors square to?\r\n                To figure this out will perform a thought experiment involving light clocks and trains.\r\n            </div>\r\n            <h5>Light clocks and trains</h5>\r\n            <div>\r\n                First of all there are great videos demonstrating what we're about to investigate. You might want to watch them first or watch them if you get confused about the writing, the videos do a much better job.\r\n                For example <a href=\"https://youtu.be/AInCqm5nCzw\">this one</a> (although they put the device on the train instead of outside of it). We won't be using mirrors here as we can get the same result without two trips which also simplifies the math a bit.\r\n            </div>\r\n            <div>\r\n                <video width=\"50%\" loop autoPlay playsInline muted>\r\n                    <source src=\"/videos/sr-trainclock-stationary.webm\" />\r\n                </video>\r\n                <video width=\"50%\" loop autoPlay playsInline muted>\r\n                    <source src=\"/videos/sr-trainclock-moving.webm\" />\r\n                </video>\r\n            </div>\r\n            <sub style={{ textAlign: \"center\", margin: \"20px\" }}>Video 1 - Left: Apparatus as seen from Alice who is at rest with it. Right: Apparatus as seen from Bob who is moving relative to it.</sub>\r\n            <ImageWithSub src=\"/images/sr-trains.png\" text=\"Figure 6 - Left: Alice 'a' has a device that sends light from bottom and receives it at the top. Middle: Bob is on a moving train and looks at the device. Right: Charlie is on another moving train and looks at the device.\" />\r\n            <h5>Setup and Alice</h5>\r\n            <div>\r\n                Consider Alice standing still on the ground with an apparatus as pictured in figure 6. The height of the apparatus is $h$.\r\n                Light is sent from the bottom with horizontal coordinate $0$ to the top in a straight line.\r\n                In this case, the light is received at the top at the same horizontal coordinate it was sent from, ie. $0$.\r\n                The time it took for the light to be sent and received is called $\\Delta t_a$.\r\n            </div>\r\n            <div>\r\n                Given the elapsed time we know that the distance the light moved must be equal to $c \\Delta t_a$ where $c$ is the speed of light.\r\n                We also already knew that the height of the apparatus is $h$ so we have\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    h = c \\\\Delta t_a\r\n                    \\\\label{eq:alice}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Point of views and Bob's view</h5>\r\n            <div>\r\n                Introduce Bob on a train. From Alice's point of view the train is moving with constant velocity $v_b$ to the left.\r\n                What exactly does \"point of view\" mean here? From our own point of view, we are always standing still and not moving in space.\r\n                For example for Bob, for himself it looks like he is standing still on the train and Alice along with her apparatus are moving with velocity\r\n                $v_b$ to the right.\r\n            </div>\r\n            <div>\r\n                How does the light in the aparatus look like from Bob's view? On sending, the light starts at horizontal coordinate $0$ and is moving upwards in the aparatus.\r\n                The second postulate of Special Relativity was that the speed of light is constant, so adding the speed of the train to the speed of light would not make sense.\r\n                What happens in reality is that the aparatus keeps on moving so it slides away from the light, while the light just keeps moving straight up from Bob's point of view.\r\n                When the light is received it is not received at the same horizontal coordinate anymore. If we look at the path the light traced out it is a diagonal. We denote\r\n                the horizontal coordinate the light was received at $x_b$ and the time it took $t_b$.\r\n            </div>\r\n            <div>\r\n                Let's look at the picture. Alice saw the light start and end at the coordinate $0$, yet Bob saw it start at $0$ and end at $x_b$. How is this possible?\r\n                It seems unintuitive to everyday life but this is what actually happens.\r\n                Using Pythagoras' theorem we can see that there is a relation between the total distance the light covered, the height of the apparatus and the horizontal distance\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    h^2 + \\\\Delta x_b^2 = (c \\\\Delta t_b)^2\r\n                    \\\\label{eq:bob}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h5>Invariant distance in Spacetime</h5>\r\n            <div>\r\n                A third person Charlie is also on a train, but moving at a different velocity $v_c$. We will get an identical equation to Bob's\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    h^2 + \\\\Delta x_c^2 = (c \\\\Delta t_c)^2\r\n                    \\\\label{eq:charlie}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Solving Alice's, Bob's and Charlie's equations {`\\\\eqref{eq:alice}, \\\\eqref{eq:bob}, \\\\eqref{eq:charlie}`} for $h^2$ (which requires squaring Alice's equation) we get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{aligned}\r\n                    h^2 & = & (c \\\\Delta t_a)^2 & \\\\\\\\\r\n                    h^2 & = & (c \\\\Delta t_b)^2 & - (\\\\Delta x_b)^2 \\\\\\\\\r\n                    h^2 & = & (c \\\\Delta t_c)^2 & - (\\\\Delta x_c)^2 \r\n                \\\\end{aligned}\r\n                `}\r\n            </div>\r\n            <div>\r\n                All three right-hand sides must be equal. Does this look familiar? Think back to passive transformations. The coefficients of a vector expressed in a different coordinate basis\r\n                might change, but the vector itself and its length does not change under passive transformations. This is exactly what happened here!\r\n                There is a small but important difference in that they have a minus sign instead of a plus sign in front of the spatial offsets, so it is not just the ordinary euclidean distance\r\n                we are dealing with here.\r\n            </div>\r\n            <div>\r\n                Note: Alice's part only appears to be missing because her spatial offset is zero (the light started and ended at the same horizontal coordinate).\r\n            </div>\r\n            <div>\r\n                In summary, all that happened was that the observers Alice, Bob and Charlie were using different coordinate systems, so the values they measured as expressed in their own coordinate systems\r\n                did not match up, even though the thing they were measuring was fundamentally the same.\r\n            </div>\r\n            <div>\r\n                What we have discovered is the distance of spacetime that we can use to measure distance between spacetime events. With all three space dimensions it is\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    d^2 = c^2 \\\\Delta t^2 - \\\\Delta x^2 - \\\\Delta y^2 - \\\\Delta z^2\r\n                    \\\\label{eq:invariantinterval}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                If this quantity is preserved, then this also implies that the usual euclidean distance in spacetime is not preserved.\r\n            </div>\r\n            <div>\r\n                Using this result we can now see what changes we need to make to our 4D algebra to arrive at the correct Spacetime Algebra.\r\n            </div>\r\n\r\n            <h4>Spacetime Algebra</h4>\r\n            <div>\r\n                The only change we need to make is to the squares of our basis vectors. Having them all square to $+1$ will give us the euclidean distance where\r\n                all signs in the distance are positive. However we want the spatial signs to be negative, so naturally we choose the spatial basis vectors to square to -1.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                $e_t^2 = 1, e_x^2 = e_y^2 = e_z^2 = -1$\r\n            </div>\r\n            <div>\r\n                This is usually refered to as the <a href=\"https://en.wikipedia.org/wiki/Spacetime_algebra\">Spacetime Algebra</a>. It has wide applications in physics\r\n                and can be used to describe for example classical electromagnetics, most parts of the standard model of particle physics and, of course, relativity.\r\n            </div>\r\n            <div>\r\n                We can now verify that squaring a difference vector gives us the correct distance {`\\\\eqref{eq:invariantinterval}`}:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{aligned}\r\n                    & ||c \\\\Delta t e_t + \\\\Delta x e_x + \\\\Delta y e_y + \\\\Delta z e_z||^2 = \\\\\\\\\r\n                    = & (c \\\\Delta t e_t + \\\\Delta x e_x + \\\\Delta y e_y + \\\\Delta z e_z) \\\\cdot (c \\\\Delta t e_t + \\\\Delta x e_x + \\\\Delta y e_y + \\\\Delta z e_z) = \\\\\\\\\r\n                    = & c^2 \\\\Delta t^2 - \\\\Delta x^2 - \\\\Delta y^2 - \\\\Delta z^2\r\n                \\\\end{aligned}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Now we also have a justification for the factor of $c$ in front of the time component. Furthermore the algebra has the following basis blades\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-basisblades.png\" text=\"Figure 7 - Basis blades of the Spacetime Algebra\" />\r\n            <div>\r\n                In Geometric Algebra we are usually very interested in the bivectors as we can use them for building rotors that\r\n                do interesting transformations which also easily compose. For example in ordinary Geometric Algebra the bivectors square to $-1$\r\n                and the resulting rotors perform ordinary rotation.\r\n            </div>\r\n            <div>\r\n                Next we will take a look at a fundamental problem that relativity solves: the addition of velocities at speeds close to the speed of light.\r\n                For this we will need to take a look at our bivectors squaring to $+1$ and their rotors.\r\n            </div>\r\n\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We started the section by looking at how we can express the paths objects take. We ended up with paths in spacetime parameterized by a parameter $\\lambda$.\r\n                Differentiating the path yields the path velocity tangent to the path. The path parameter is called $\\tau$ when the path velocity squares to $c^2$.\r\n            </div>\r\n            <div>\r\n                We then saw that the points in spacetime are events containing both a space and time coordinate, and that we had to multiply our\r\n                time component by the speed of light for the units to make sense.\r\n            </div>\r\n            <div>\r\n                After this we turned our attention to paths again and looked at different kinds of paths of objects in spacetime. Paths of objects at rest\r\n                are straight lines in the $e_t$ direction. Paths with constant velocity are straight lines in both time and space directions. Light paths\r\n                are at 45° angles in our diagrams and nothing can have an angle less steep than this.\r\n            </div>\r\n            <div>\r\n                Finally we performed a thought experiment involving a light clock and different observers going at different velocities relative to it to uncover a distance metric for our spacetime.\r\n                This led to the introduction of the Spacetime Algebra with $e_t$ squaring to $1$ and $e_x, e_y, e_z$ squaring to $-1$.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Path in spacetime: {`$s(\\\\lambda)$`}</li>\r\n                    <li>Path velocity: {`$\\\\frac{\\\\partial}{\\\\partial \\\\lambda} s(\\\\lambda)$`}</li>\r\n                    <li>Path velocity of object at rest: {`$\\\\frac{\\\\partial}{\\\\partial \\\\lambda} s(\\\\lambda) \\\\propto e_t$`}</li>\r\n                    <li>Path parameterized by proper time: {`$s(\\\\tau), \\\\dot{s}(\\\\tau) = \\\\frac{\\\\partial}{\\\\partial \\\\tau} s(\\\\tau), \\\\dot{s}(\\\\tau)^2 = c^2$`}</li>\r\n                    <li>Spacetime distance / invariant interval: {`$d^2 = c^2 \\\\Delta t^2 - \\\\Delta x^2 - \\\\Delta y^2 - \\\\Delta z^2$`}</li>\r\n                    <li>Spacetime Algebra: {`$e_t^2 = 1, e_x^2 = e_y^2 = e_z^2 = -1$`}</li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Next we will look at a problem that arises when adding velocities close to the speed of light with ordinary addition, and we will see\r\n                how the bivectors squaring to $+1$ can be used to solve the problem.\r\n            </div>\r\n\r\n            <h4><Link to=\"/sr-spacetime-rotors\">Special Relativity with Geometric Algebra - Spacetime Rotors</Link></h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\n\r\nexport function SRMeasuring() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Measuring in Spacetime</h3>\r\n            <div>\r\n                In the previous section we derived the Spacetime Algebra used all over GA formualtions of physics. As a next step we need to take a look at\r\n                how space and time measurements are done in it. For this we will first look at how it is done in ordinary space, and then we will try to figure out\r\n                how to do it for spacetime.\r\n            </div>\r\n            <h4>Measuring in Ordinary Space</h4>\r\n            <div>\r\n                We want to measure the size of an object in ordinary space. The thing we want to measure has endpoints $a$ and $b$, for example a stick.\r\n                The endpoints can be represented by position vectors, and we can form a difference vector $v$ which encodes the extents in each dimension of space.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                a & = a_x e_x + a_y e_y \\\\\\\\\r\n                b & = b_x e_x + b_y e_y \\\\\\\\\r\n                v & = b - a\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                To measure the length of the stick in the X direction, we calculate the inner product with the $e_x$ basis vector, because then\r\n                we pick out exactly the X component of the difference vector. And same for the Y component.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                v & = v_x e_x + v_y e_y \\\\\\\\\r\n                v \\\\cdot e_x & = (v_x e_x + v_y e_y) \\\\cdot e_x = v_x \\\\\\\\\r\n                v \\\\cdot e_y & = (v_x e_x + v_y e_y) \\\\cdot e_y = v_y\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <h4>Measuring in Spacetime</h4>\r\n            <div>\r\n                Does this idea still work in Spacetime? We start by doing exactly the same thing as in ordinary space. We have two events (points in spacetime, having position and time)\r\n                and we want to measure the difference vector. The difference vector contains both a spatial distance (its $e_x$ component) as well as a time difference (its $e_t$ component).\r\n            </div>\r\n            <div>\r\n                As before, we try doing the inner product with $e_t$ and $e_x$ to attempt picking out their respective components:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                v & = v_t e_t + v_x e_x \\\\\\\\\r\n                v \\\\cdot e_t & = (v_x e_x + v_t e_t) \\\\cdot e_t = v_t \\\\\\\\\r\n                v \\\\cdot e_x & = (v_x e_x + v_y e_y) \\\\cdot e_x = -v_x\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Did we succeed? Not exactly. The t component is fine, however the x component picked up a minus sign because our spatial basis vectors square to $-1$ in\r\n                the Spacetime Algebra. How do we fix this?\r\n            </div>\r\n            <h4>Reciprocal frames</h4>\r\n            <ImageWithSub src=\"/images/sr-reciprocal-frame.png\" width=\"60%\" text=\"Light blue: Basis vectors. Blue: Reciprocal basis vectors. Orange: Vector we want to measure. Yellow: Desired measurement results.\" />\r\n            <div>\r\n                What we really wanted for measuring the component along one basis vector is a vector whose inner product with it is $1$, and $0$ with all other basis vectors.\r\n                We call these vectors reciprocal. For ordinary space with an orthonormal basis, each basis vector is already its own reciprocal basis vector.\r\n            </div>\r\n            <div>\r\n                In the Spacetime Algebra the spatial basis vectors square to $-1$ so this is not the case anymore.\r\n                For example the reciprocal vector for $e_x$ is $-e_x$ because $e_x \\cdot -e_x = 1$ and $e_t \\cdot -e_x = 0$.\r\n            </div>\r\n            <div>\r\n                The collection of reciprocal basis vectors is called a reciprocal frame.\r\n                We write the reciprocal basis vectors using upstairs letters. For example $e^x$ is the reciprocal basis vector for $e_x$.\r\n                For the 4 dimensional Spacetime Algebra we have the following reciprocal frame:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                \\\\begin{aligned}\r\n                e^t & = e_t \\\\\\\\\r\n                e^x & = -e_x \\\\\\\\\r\n                e^y & = -e_y \\\\\\\\\r\n                e^z & = -e_z\r\n                \\\\end{aligned}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Applying this to the first example where we initially failed we get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                v \\\\cdot e^x = (v_x e_x + v_y e_y) \\\\cdot -e_x = v_x\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                which is the result we wanted.\r\n            </div>\r\n            <h4>General formula for Reciprocal Frames</h4>\r\n            <div>\r\n                Another application for reciprocal frames are curvilinear coordinate systems. Here we can have basis vectors which\r\n                square to neither $1$ nor $-1$. For example the radial basis vector in spherical coordinates will square to $r^2$.\r\n                For our Spacetime Algebra basis vectors it was easy to find the reciprocal basis vectors just by inspection, but here it is trickier.\r\n            </div>\r\n            <div>\r\n                Fortunately a very simple formula exists for finding the reciprocal frame for a set of basis vectors in general:\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                e^i = \\\\frac{\\\\bigwedge_{j \\\\neq i} e_j}{\\\\bigwedge_j e_j} = \\\\frac{\\\\bigwedge_{j \\\\neq i} e_j}{I}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                In words, we take the wedge product of all our basis vectors in order except for the one we try to find the reciprocal for and divide by the pseudoscalar.\r\n                For example applying this to our Spacetime Algebra's $e_x$ we get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                e^x = \\\\frac{e_t \\\\wedge e_y \\\\wedge e_z}{e_t \\\\wedge e_x \\\\wedge e_y \\\\wedge e_z} = -e_{tyztxyz} = -e_x\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We won't use this formula nor curvilinear coordinate systems in the rest of this series but I thought it is simple and important enough to mention here.\r\n            </div>\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We looked at how measurements are done in ordinary space. Then we saw this way of measuring breaks for our Spacetime Algebra. We found\r\n                that using reciprocal frames solves this and we wrote down the reciprocal basis vectors for our Spacetime Algebra's basis vectors.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Reciprocal basis vectors: {`$e^i \\\\cdot e_j = \\\\delta_j^i$`}</li>\r\n                    <li>Measure $e_i$ component of vector: {`$e^i \\\\cdot v = v_i$`}</li>\r\n                    <li>Spacetime Algebra reciprocal basis vectors: {`$e^t = e_t, e^x = -e_x, e^y = -e_y, e^z = -e_z$`}</li>\r\n                    <li>Finding reciprocal basis vectors in general: {`$e^i = \\\\frac{\\\\bigwedge_{j \\\\neq i} e_j}{\\\\bigwedge_j e_j} = \\\\frac{\\\\bigwedge_{j \\\\neq i} e_j}{I}$`}</li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Now that we know how to take measurements of vectors, we will look at how observers at different relative speeds measure the same objects.\r\n            </div>\r\n            <h4><Link to=\"/sr-time-dilation\">Special Relativity with Geometric Algebra - Time Dilation</Link></h4>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\nimport { Link } from \"react-router-dom\"\r\nimport { ImageWithSub, useMathJax } from \"../util\"\r\n\r\nexport function SRSpacetimeRotors() {\r\n    useMathJax()\r\n\r\n    return (\r\n        <div>\r\n            <h3>Special Relativity with Geometric Algebra - Spacetime Rotors</h3>\r\n            <h4>Velocity addition close to the speed of light</h4>\r\n            <div>\r\n                To motivate spacetime rotors, we need more trains (these are very popular in relativity apparently). \r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-addvel.png\" text=\"Figure 1 - Left: Alice is on a train throwing a ball and sees Bob outside the train, Right: Bob looks at Alice throwing a ball in her moving train\" width=\"90%\" />\r\n            <div>\r\n                Consider Alice is now on a train. On the train, she is throwing a ball with speed $0.4c$ (yes, yes... very contrived).\r\n                Outside of the train is Bob who can see the train moving at $0.8c$. Alice, on the train, sees herself standing still but sees Bob\r\n                passing by her at $-0.8c$ (ie. same speed but in the opposite direction of the train). We can now ask the question of how fast is the ball moving from the point of view of Bob.\r\n            </div>\r\n            <div>\r\n                If we just add up the speed of the train as seen by Bob and the speed of the ball as seen by Alice we get $0.8c + 0.4c = 1.2c$ but this can't be as nothing can exceed the speed of light.\r\n                Let's recall some things:\r\n            </div>\r\n            <div>\r\n                <ul>\r\n                    <li>From the paths section we know that the angle of paths is related to their speed</li>\r\n                    <li>We also know that resting observers have path velocities proportional to $e_t$</li>\r\n                    <li>Claim: We can use our new rotors to rotate between path velocities to find the correct velocity from Bob's perspective</li>\r\n                </ul>\r\n            </div>\r\n            <div>\r\n                Okay this might sound far-fetched first. Rotate between spacetime velocities? Let's look at this sketch.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-rotors.png\" text=\"Figure 2 - Diagonal yellow: Light. Left: Alice's view, Alice (blue) is at rest, Bob (purple) moves left, Ball (green) moves right. Right: Bob's view, Alice (blue) moves right, Bob (purple) is at rest, Ball (green) is moves right.\" />\r\n            <h5>Alice's view (left)</h5>\r\n            <div>\r\n                Alice (blue) is at rest so her path velocity vector points in her $e_t$ direction.\r\n                From Alice's view Bob (purple) is moving left so his velocity vector points left. The rotation from Bob's to Alice's velocity vector is done by applying the rotor $R_1$ to Bob's velocity vector.\r\n                The ball moves to the right, so its velocity vector is rotated to the right. The rotation between Alice and the ball is done with the rotor $R_2$.\r\n            </div>\r\n            <div>\r\n                The rotations between these vectors are all active transformations because the three velocity vectors are actually different from each other\r\n                and it is not just Alice changing her perspective on a single unchanging vector.\r\n            </div>\r\n            <h5>Bob's view (right)</h5>\r\n            <div>\r\n                Bob's velocity vector (purple) is at rest, ie. points in his $e_t$ direction. Alice's velocity vector is rotated right with $R_1$ and the ball is rotated relative to Alice's velocity vector with $R_2$.\r\n            </div>\r\n            <h5>Velocity Rotors</h5>\r\n            <div>\r\n                Now the key observation: the rotors in the left and the right diagram are identical. The values in them are the same (unlike for the vectors!). So if we know them in one diagram we can use them in the other.\r\n                We know $R_1$ from both views, but we only know $R_2$ from Alice's view. But if we calcualte $R_2$ in Alice's view, we can just apply it to Alice's velocity vector in Bob's view.\r\n            </div>\r\n            <div>\r\n                So that's the idea. How to actually do this and how the angle relates to the speed comes in the next section.\r\n            </div>\r\n\r\n            <h4>Rotors in the Spacetime Algebra</h4>\r\n            <div>\r\n                To continue, we need to look at what the rotors in the Spacetime Algebra actually do. We will only need the rotors for bivectors squaring to $+1$, ie. {`$e_{tx}, e_{ty}, e_{tz}$`}.\r\n                Let's stick with {`$e_{tx}$`} for now. How do we get rotors from bivectors? We stick them in the exponential function with an angle $\\varphi$, usually negated and halved because we need to apply a\r\n                two-sided product.\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    R(\\\\varphi) = e^{-\\\\frac{\\\\varphi}{2}e_{tx}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Can we expand this further? Usually we get something involving sine and cosine for performing ordinary rotations, but that is because the bivector in the exponential squared to $-1$.\r\n                It turns out in the case of $+1$ we get hyperbolic sine and hyperbolic cosine. You can get this result by using the taylor series for the exponential function and comparing\r\n                it with the taylor series of the hyperbolic sine and cosine functions. Anyway, we now get\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    R(\\\\varphi) = e^{-\\\\frac{\\\\varphi}{2}e_{tx}} = cosh(-\\\\frac{\\\\varphi}{2}) + sinh(-\\\\frac{\\\\varphi}{2}) e_{tx}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                What does this rotor do? It's not ordinary rotation, it is hyperbolic rotation! What is hyperbolic rotation? I promised you earlier we could use these rotors to\r\n                rotate velocity vectors and use them for velocity addition. Let's apply them to the rest velocity vector $e_t$ and see what we can infer from that\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    R(\\\\varphi) e_t \\\\widetilde{R}(\\\\varphi) = cosh(\\\\varphi) e_t + sinh(\\\\varphi) e_x\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                The steps between the left-hand side and right-hand side are left as an excercise. This will require some identities involving the hyperbolic sine and cosine functions, or\r\n                you can just throw them into Wolfram Alpha to see what the parts simplify to.\r\n            </div>\r\n            <div>\r\n                We can see the result is some mix of $e_t$ and $e_x$.\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-rotors2.png\" text=\"Figure 3 - Yellow: Light. Dark blue: Velocity of object at rest. Light blue: Velocity of moving object. Orange: Rotor between object at rest and moving object.\" width=\"50%\" />\r\n            <div>\r\n                To get some more intuition let's look at the slope of the result. The $e_t$ part is on the y-axis and the $e_x$ part is on the x-axis\r\n                so we have\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    slope(\\\\varphi) = \\\\frac{sinh(\\\\varphi)}{cosh(\\\\varphi)} = \\\\frac{1}{tanh{\\\\varphi}}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                So the slope is equal to one over the hyperbolic tangent $tanh$. If you're familiar with neural networks you probably already know how the $tanh$ function looks (and perhaps other fields I'm not familiar with).\r\n                Here's a sketch\r\n            </div>\r\n            <ImageWithSub src=\"/images/sr-tanh.png\" text=\"Figure 4 - Hyperbolic tangent function, zero at phi equal to 0, one towards positive and negative infinity.\" width=\"50%\" />\r\n            <div>\r\n                The second part we need for plotting what the result looks like is the length of the resulting vector. The length in our graph is the euclidean length. This is of course not the length / distance\r\n                we use in the algebra, but in our drawings, if the $e_x$ and $e_t$ components get bigger, then the vector we draw always gets bigger too. So we also have\r\n            </div>\r\n\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    graphlength(\\\\varphi) = \\\\sqrt{cosh^2(\\\\varphi) + sinh^2(\\\\varphi)}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                Now we take a deeper look at the slope result we got earlier for different rotor angles $\\varphi$.\r\n            </div>\r\n            <div>\r\n                If $\\varphi = 0$, then the slope is $\\infty$ (vertical) and the graph length is $1$.\r\n                This makes sense as rotating by $0$ should leave the input unchanged.\r\n                Furthermore, for $\\varphi \\to \\infty$, we can see that $slope \\to 1$. As we increase the angle of the rotor, the slope tends towards $1$. A slope of $1$ is a 45° angle. Recall that\r\n                light travels at 45° angles, so this is good! If we increase the angle, our velocity vector rotates towards the speed of light.\r\n                Using these rotors we can never exceed (or even reach) 45°. Finally, the length also tends towards infinity, meaning if we rotate the rest\r\n                velocity vector, its length will always increase.\r\n            </div>\r\n            <h5>Relation between velocity and angle</h5>\r\n            <div>\r\n                Given what we learnt, we can try to figure out the relationship between the angle $\\varphi$ and the velocity $v$.\r\n                We know that the slope for light is $1$, so {`$tanh(\\\\varphi_{light}) = 1$`}. We also know that the rest velocity\r\n                has slope infinity (vertical), ie. {`$tanh(0) = 0$`}. Based on these two data points, what do you think the relation is?\r\n                The correct answer that also fits both data points is\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    tanh(\\\\varphi) = \\\\frac{v}{c}\r\n                    \\\\label{eq:anglevelocity}\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                We will use this relation in the next section to finally solve our velocity addition problem.\r\n            </div>\r\n\r\n            <h4>Velocity addition close to the speed of light: revisited</h4>\r\n            <ImageWithSub src=\"/images/sr-rotors.png\" text=\"Figure 5 - Diagonal yellow: Light. Left: Alice's view, Alice (blue) is at rest, Bob (purple) moves left, Ball (green) moves right. Right: Bob's view, Alice (blue) moves right, Bob (purple) is at rest, Ball (green) is moves right.\" />\r\n            <div>\r\n                And we're back. This time equipped with the power of rotors that can rotate velocities and the relation between angles and velocities!\r\n                We want to figure out the velocity of the ball from Bob's perspective (which we don't know yet). For that we look at Bob's frame where he is at rest and apply the two rotors (which we do know).\r\n                Let me show you one more thing (that you probably already knew!) about rotors before we tackle the problem.\r\n            </div>\r\n            <div>\r\n                When we compose two rotors in the same plane we get (no matter what the bivector squares to)\r\n            </div>\r\n            <div style={{ padding: 20 }}>\r\n                {`\r\n                \\\\begin{equation}\r\n                    R(\\\\varphi_1) R(\\\\varphi_2) = e^{-\\\\frac{\\\\varphi_1}{2}e_{tx}} e^{-\\\\frac{\\\\varphi_2}{2}e_{tx}} = e^{-\\\\frac{\\\\varphi_1 + \\\\varphi_2}{2}e_{tx}} = R(\\\\varphi_1 + \\\\varphi_2)\r\n                \\\\end{equation}\r\n                `}\r\n            </div>\r\n            <div>\r\n                When composing two rotations the angles just add. This is still the case even with our hyperbolic rotations. It turns out to solve the problems\r\n                we don't even need to use rotors directly. First we calculate the two angles corresponding to the two velocities we were given. To get the angle from velocity we solve {`\\\\eqref{eq:anglevelocity}`} for $v$.\r\n                Then we add the angles. Finally we need to convert the resulting angle back to a velocity using {`\\\\eqref{eq:anglevelocity}`}, and that will be the velocity of the ball as seen from Bob.\r\n            </div>\r\n            {`\r\n            \\\\begin{equation}\r\n                v_{ball} = c \\\\cdot tanh(\\\\varphi_1 + \\\\varphi_2) = c \\\\cdot tanh(tanh^{-1}(0.8) + tanh^{-1}(0.4)) \\\\approx 0.9c\r\n            \\\\end{equation}\r\n            `}\r\n            <div>\r\n                The ball moves at around $0.9c$ from Bob's perspective.\r\n            </div>\r\n\r\n            <h4>Conclusion</h4>\r\n            <div>\r\n                We started by noticing that adding velocities close to the speed of light fails with ordinary addition because the speed of light can be exceeded.\r\n                We then saw how we can relate velocity vectors using rotors with bivectors that square to $+1$. We noticed that these rotors rotate velocity vectors\r\n                towards the speed of light but never exceed it. We also saw that the rotors don't change with passive transformations so we could compose them\r\n                to solve our velocity addition problem. The result was that we can add the rotor angles for rotors in the same plane and relate them to velocities\r\n                using the formula {`$tanh(\\\\varphi) = \\\\frac{v}{c}$`}.\r\n            </div>\r\n            <h4>Formulas</h4>\r\n            <div>\r\n                <ul>\r\n                    <li>Relation between angle and velocity: {`$tanh(\\\\varphi) = \\\\frac{v}{c}$`}</li>\r\n                    <li>Addition of angles: {`$\\\\varphi_{a+b} = \\\\varphi_a + \\\\varphi_b$`}</li>\r\n                    <li>Addition of velocities: {`$v_{a+b} = c \\\\cdot tanh(\\\\varphi_{a+b}) = c \\\\cdot tanh(tanh^{-1}(\\\\frac{v_a}{c}) + tanh^{-1}(\\\\frac{v_b}{c}))$`}</li>\r\n                </ul>\r\n            </div>\r\n            <h4>Up next</h4>\r\n            <div>\r\n                Next we will look at how we can take measurements in Spacetime.\r\n            </div>\r\n            \r\n            <h4><Link to=\"/sr-measuring\">Special Relativity with Geometric Algebra - Measuring in Spacetime</Link></h4>\r\n        </div>\r\n    )\r\n}"],"sourceRoot":""}